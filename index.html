<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DRM MCHN - Beatdown</title>
  <style>
    :root {
      --bg: #0d1116;
      --panel: #131a22;
      --panel-2: #1a232d;
      --panel-3: #0f151c;
      --text: #e7edf3;
      --muted: #8fa1b3;
      --accent: #f5c542;
      --accent-2: #2bd4a4;
      --danger: #ff6b6b;
      --shadow: 0 12px 30px rgba(0,0,0,0.35);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      background: radial-gradient(1200px 800px at 10% 0%, #1b2633 0%, var(--bg) 50%, #0a0f14 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }
    .app {
      width: min(1200px, 100%);
      background: linear-gradient(135deg, var(--panel) 0%, #0e1319 100%);
      border: 1px solid #222c36;
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 24px;
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 18px;
    }
    h1 {
      font-size: 22px;
      letter-spacing: 2px;
      text-transform: uppercase;
      margin: 0;
    }
    .transport {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    button {
      background: var(--panel-2);
      color: var(--text);
      border: 1px solid #273240;
      border-radius: 8px;
      padding: 10px 14px;
      cursor: pointer;
      font-weight: 600;
    }
    button.primary {
      background: linear-gradient(140deg, #2d3f50, #1f2a34);
      border-color: #334354;
    }
    button.active {
      box-shadow: 0 0 0 2px var(--accent) inset;
      color: var(--accent);
    }
    button.danger {
      color: var(--danger);
      border-color: #4e2a2a;
    }
    .row {
      display: grid;
      grid-template-columns: 120px 1fr 110px 90px;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    .label {
      font-size: 14px;
      letter-spacing: 1px;
      color: var(--muted);
      text-transform: uppercase;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(16, minmax(26px, 1fr));
      gap: 6px;
      position: relative;
    }
    .step {
      width: 100%;
      aspect-ratio: 1 / 1;
      border-radius: 6px;
      background: #0f151c;
      border: 1px solid #24303a;
      cursor: pointer;
      transition: transform 0.05s ease, box-shadow 0.15s ease, opacity 0.15s ease;
      position: relative;
    }
    .step.on {
      background: var(--accent);
      border-color: #cc9d1d;
    }
    .step.current {
      box-shadow: 0 0 0 2px var(--accent-2) inset;
    }
    .step:active { transform: scale(0.96); }
    .step::after {
      content: attr(data-vel);
      position: absolute;
      bottom: 2px;
      right: 4px;
      font-size: 9px;
      color: rgba(0,0,0,0.5);
      opacity: 0;
      transition: opacity 0.12s ease;
    }
    .step:hover::after,
    .step.selected::after,
    body.show-velocity .step.on::after {
      opacity: 1;
    }
    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 360px;
      gap: 16px;
      align-items: start;
      margin-top: 18px;
    }
    .left-col,
    .right-col {
      display: flex;
      flex-direction: column;
      gap: 16px;
      min-width: 0;
    }
    .top-controls,
    .bottom-controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 12px;
    }
    .xy-pad {
      position: relative;
      width: 100%;
      aspect-ratio: 1 / 1;
      background: linear-gradient(135deg, #0b1117 0%, #1b2633 100%);
      border: 1px solid #273240;
      border-radius: 12px;
      overflow: hidden;
      cursor: crosshair;
    }
    .xy-crosshair {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .xy-crosshair::before,
    .xy-crosshair::after {
      content: "";
      position: absolute;
      background: rgba(245, 197, 66, 0.4);
    }
    .xy-crosshair::before {
      width: 1px;
      height: 100%;
      left: var(--x, 50%);
      top: 0;
    }
    .xy-crosshair::after {
      height: 1px;
      width: 100%;
      top: var(--y, 50%);
      left: 0;
    }
    .xy-handle {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(245, 197, 66, 0.3);
      transform: translate(-50%, -50%);
      left: var(--x, 50%);
      top: var(--y, 50%);
      pointer-events: none;
    }
    .faders {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
      gap: 10px;
      align-items: end;
    }
    .fader {
      display: grid;
      gap: 6px;
      justify-items: center;
      font-size: 11px;
      color: var(--muted);
    }
    .fader input[type="range"] {
      writing-mode: bt-lr;
      appearance: slider-vertical;
      width: 18px;
      height: 140px;
    }
    .knob-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
      gap: 12px;
    }
    .knob {
      display: grid;
      gap: 6px;
      justify-items: center;
      font-size: 11px;
      color: var(--muted);
    }
    .knob-visual {
      width: 52px;
      height: 52px;
      border-radius: 50%;
      background: conic-gradient(var(--accent) var(--angle, 0deg), #1f2a34 0deg);
      position: relative;
      border: 1px solid #2a3642;
    }
    .knob-visual::after {
      content: "";
      position: absolute;
      width: 4px;
      height: 16px;
      background: #0f151c;
      top: 6px;
      left: 50%;
      transform: translateX(-50%) rotate(var(--angle, 0deg));
      transform-origin: 50% 20px;
      border-radius: 2px;
    }
    .knob input[type="range"] {
      width: 100%;
    }
    .card {
      background: var(--panel-2);
      border-radius: 12px;
      padding: 12px;
      border: 1px solid #273240;
    }
    .card h3 {
      margin: 0 0 10px;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--muted);
    }
    .group-label {
      margin: 10px 0 6px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1.1px;
      color: #8aa3b6;
      opacity: 0.9;
    }
    .stress-wrap {
      display: grid;
      grid-template-columns: 16px 1fr;
      gap: 8px;
      align-items: end;
      margin: 8px 0 10px;
    }
    .stress-meter {
      height: 72px;
      border: 1px solid #2b3a48;
      background: #0f151c;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }
    .stress-fill {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 0%;
      background: linear-gradient(180deg, #f0d26a 0%, #e59f3a 45%, #d15d4f 100%);
      transition: height 120ms linear;
    }
    .stress-meta {
      display: grid;
      gap: 2px;
    }
    input[type="range"], select {
      width: 100%;
    }
    .small {
      font-size: 12px;
      color: var(--muted);
    }
    .track-controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }
    .track-card {
      background: var(--panel-3);
      border-radius: 12px;
      padding: 12px;
      border: 1px solid #22303c;
    }
    .track-card h4 {
      margin: 0 0 8px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--muted);
    }
    .inline {
      display: grid;
      grid-template-columns: 1fr 60px;
      gap: 6px;
      align-items: center;
      margin-bottom: 6px;
    }
    .mute {
      padding: 6px 10px;
      font-size: 12px;
    }
    .channel-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-height: 30px;
      line-height: 1;
      white-space: nowrap;
    }
    .solo {
      padding: 6px 10px;
      font-size: 12px;
    }
    .solo.active {
      color: var(--accent-2);
      box-shadow: 0 0 0 2px var(--accent-2) inset;
    }
    .tensor-toggle {
      padding: 6px 8px;
      font-size: 11px;
      letter-spacing: 0.4px;
    }
    .tensor-toggle.active {
      color: #8fd9ff;
      box-shadow: 0 0 0 2px #4a84a3 inset;
    }
    .hint {
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
      opacity: 0.58;
    }
    .preset-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
      gap: 8px;
      margin-top: 8px;
    }
    .preset-row button {
      width: 100%;
    }
    .sketch-controls {
      display: grid;
      gap: 8px;
      margin-top: 8px;
    }
    .sketch-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
    }
    .sketch-select {
      display: grid;
      gap: 4px;
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.6px;
    }
    .sketch-select select {
      background: var(--panel-3);
      color: var(--text);
      border: 1px solid #263341;
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 13px;
    }
    .sketch-locks {
      display: grid;
      gap: 6px;
    }
    .lock-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px 12px;
      align-items: center;
    }
    .lock-pill {
      display: inline-flex;
      align-items: center;
      justify-content: flex-start;
      gap: 10px;
      padding: 8px 14px;
      border-radius: 999px;
      min-height: 40px;
      box-sizing: border-box;
      width: 100%;
      background: var(--panel-3);
      border: 1px solid #263341;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      color: var(--muted);
      cursor: pointer;
    }
    .lock-pill .pill-check {
      flex: 0 0 auto;
      accent-color: var(--accent);
      cursor: pointer;
    }
    .lock-pill .pill-label {
      flex: 1 1 auto;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1;
      display: block;
    }
    .sketch-inline {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: space-between;
    }
    .variation-meter {
      height: 8px;
      background: #0f151c;
      border: 1px solid #263341;
      border-radius: 999px;
      overflow: hidden;
      position: relative;
      flex: 1 1 auto;
      min-width: 120px;
    }
    .variation-meter span {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #2bd4a4, #f5c542, #ff6b6b);
      transition: width 0.2s ease;
    }
    .sketch-summary {
      line-height: 1.4;
      color: var(--muted);
    }
    #quickSketchCard .preset-row button,
    #sketchSurprise {
      border-color: #3a4a5b;
      box-shadow: 0 2px 10px rgba(0,0,0,0.22);
    }
    .section-toggle {
      width: 100%;
      display: inline-flex;
      align-items: center;
      justify-content: space-between;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      font-size: 11px;
      padding: 8px 10px;
      margin-bottom: 8px;
    }
    .section-toggle.subtle {
      background: #0f151c;
      border-color: #22303c;
      font-size: 10px;
      margin-bottom: 6px;
    }
    .section-body.collapsed {
      display: none;
    }
    .palette-panel {
      background: #10161d;
      border: 1px solid #1f2933;
      border-radius: 12px;
      padding: 10px 12px;
    }
    .palette-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 6px 10px;
      font-size: 11px;
      color: var(--muted);
    }
    .palette-item {
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }
    .palette-tag {
      color: var(--accent-2);
      font-weight: 600;
    }

    /* Layout stabilization overrides */
    html, body {
      height: 100%;
      margin: 0;
    }

    body {
      overflow-x: hidden;
      overflow-y: auto;
      display: block;
      padding: 0;
      align-items: initial;
      justify-content: initial;
    }

    .app {
      width: 100%;
      min-height: 100dvh;
      height: auto;
      border-radius: 0;
      border: 0;
      display: grid;
      grid-template-rows: auto 1fr auto auto;
      gap: 12px;
      padding: 16px;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 430px;
      gap: 16px;
      min-height: 0;
      align-items: start;
      margin-top: 0;
    }

    .left-col {
      min-width: 0;
      min-height: 0;
      overflow: visible;
    }

    .right-col {
      width: 430px;
      min-width: 430px;
      max-width: 430px;
      min-height: 0;
      overflow: visible;
    }

    .mode-switch {
      display: inline-flex;
      gap: 6px;
      padding-left: 4px;
    }

    .context-panel {
      height: 100%;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .context-tabs {
      flex: 0 0 auto;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;
      margin-bottom: 10px;
    }

    .tab-btn {
      width: 100%;
      padding: 10px 8px;
      font-size: 12px;
      letter-spacing: 0.8px;
      color: #9aabbb;
      background: #10161d;
      border-color: #21303d;
      transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
    }
    .tab-btn.active {
      color: var(--text);
      background: #1f2b36;
      border-color: #41566d;
      box-shadow: 0 0 0 1px #4e647b inset;
    }

    .context-body {
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      overflow-x: hidden;
      display: grid;
      background: #0f151c;
      border: 1px solid #1e2833;
      border-radius: 12px;
      padding: 10px;
      max-height: min(68vh, 760px);
    }

    .tab-panel {
      display: none;
      align-content: start;
      gap: 12px;
      min-width: 0;
    }

    .tab-panel.active {
      display: grid;
      animation: tabFade 0.15s ease;
    }
    .tab-panel .card {
      background: #121a23;
      border-color: #253241;
    }
    .tab-panel[data-panel="track"] .card:first-child,
    .tab-panel[data-panel="mix"] .card:first-child {
      background: #17212c;
      border-color: #344759;
    }
    .tab-panel[data-panel="generator"] #quickSketchCard {
      background: #18222d;
      border-color: #3a4e60;
      box-shadow: 0 0 0 1px rgba(245, 197, 66, 0.08) inset;
    }
    .tab-panel[data-panel="generator"] #genreSketchCard {
      background: #111820;
      border-color: #24313d;
    }
    @keyframes tabFade {
      from { opacity: 0; transform: translateY(3px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .sequencer-wrap {
      display: grid;
      grid-template-columns: 236px minmax(0, 1fr);
      gap: 12px;
      min-height: 0;
      align-items: start;
      background: linear-gradient(180deg, #101922 0%, #0b1016 100%);
      border: 1px solid #253241;
      border-radius: 12px;
      padding: 10px;
      box-shadow: inset 0 0 0 1px rgba(16, 26, 36, 0.8);
    }

    .track-strip {
      width: 236px;
      min-width: 236px;
      display: grid;
      gap: 10px;
    }

    .step-area {
      min-width: 0;
      min-height: 360px;
      overflow: hidden;
    }

    #sequencer {
      width: 100%;
      min-height: 360px;
      display: grid;
      gap: 10px;
    }

    .strip-row,
    .seq-row {
      min-height: 40px;
      display: grid;
      align-items: center;
      transition: background 0.15s ease, opacity 0.15s ease, border-color 0.15s ease;
    }

    .strip-row {
      grid-template-columns: minmax(42px, 1fr) 40px 40px 40px 40px;
      gap: 4px;
    }
    .strip-name {
      justify-self: start;
      align-self: center;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .strip-mute,
    .strip-solo,
    .strip-tensor {
      justify-self: center;
      align-self: center;
      width: 40px;
    }
    .strip-tone {
      justify-self: center;
      align-self: center;
      font-size: 11px;
      letter-spacing: 0.8px;
      min-width: 40px;
      text-align: center;
    }

    .seq-row {
      grid-template-columns: 1fr;
      border-left: 2px solid transparent;
      border-radius: 8px;
      padding-left: 4px;
    }
    .strip-row.is-selected,
    .seq-row.is-selected {
      background: rgba(245, 197, 66, 0.11);
    }
    .seq-row.is-selected {
      border-left-color: var(--accent);
    }
    .track-strip.focus-active .strip-row:not(.is-selected),
    #sequencer.focus-active .seq-row:not(.is-selected) {
      opacity: 0.84;
    }
    .strip-row.solo-muted,
    .seq-row.solo-muted {
      opacity: 0.45 !important;
    }

    .top-controls {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 8px;
    }
    #tempoCard,
    #xyCard {
      padding: 10px;
    }
    #tempoCard h3,
    #xyCard h3 {
      margin-bottom: 8px;
    }

    .bottom-controls:empty {
      display: none;
    }

    .track-controls {
      display: none;
      margin-top: 0;
      max-height: 36vh;
      overflow-y: auto;
    }

    body.mode-perform .track-controls {
      display: grid;
    }
    body.mode-sketch .step-area {
      min-height: 300px;
    }
    body.mode-perform .left-col .top-controls {
      opacity: 0.48;
      filter: saturate(0.85);
    }
    body.mode-perform .sequencer-wrap,
    body.mode-perform #fadersCard {
      box-shadow: 0 0 0 1px rgba(245, 197, 66, 0.34) inset;
    }
    body:not(.mode-sketch) .hint {
      display: none;
    }
    .mode-switch {
      gap: 8px;
      padding-left: 8px;
    }
    .mode-switch button.active {
      box-shadow: 0 0 0 2px var(--accent) inset, 0 0 14px rgba(245, 197, 66, 0.2);
    }
    .step.pulse {
      animation: stepPulse 0.16s ease;
    }
    @keyframes stepPulse {
      from { box-shadow: 0 0 0 0 rgba(245, 197, 66, 0.55); }
      to { box-shadow: 0 0 0 10px rgba(245, 197, 66, 0); }
    }
    .lock-pill.locked {
      border-color: #7f6625;
      color: #d7c384;
      background: #1a1f1f;
      box-shadow: 0 0 0 1px rgba(245, 197, 66, 0.18) inset;
    }
    #sequencer .step {
      background: #0c131a;
      border-color: #1f2b36;
    }
    #sequencer .step.on {
      background: #f0be3d;
      border-color: #c89a1e;
    }
    #genreSketchCard .section-toggle {
      border-color: #334250;
      background: #121a23;
    }
    #genreSketchCard .section-body {
      border-top: 1px solid #22303d;
      padding-top: 8px;
    }
    .hint {
      opacity: 0.46;
    }
    .tab-panel[data-panel="groove"] #xyCard .xy-pad {
      aspect-ratio: 16 / 10;
      max-height: 180px;
    }

    @media (max-width: 1120px) {
      .app {
        padding: 12px;
        gap: 10px;
      }
      .layout {
        grid-template-columns: minmax(0, 1fr) 390px;
        gap: 12px;
      }
      .right-col {
        width: 390px;
        min-width: 390px;
        max-width: 390px;
      }
      .context-tabs {
        gap: 6px;
      }
      .tab-btn {
        font-size: 11px;
        padding: 9px 6px;
      }
    }

    @media (max-width: 920px) {
      html, body {
        height: auto;
      }
      body {
        overflow: auto;
      }
      .app {
        height: auto;
        min-height: 100dvh;
        grid-template-rows: auto auto auto auto;
      }
      .layout {
        grid-template-columns: 1fr;
        gap: 12px;
      }
      .right-col {
        width: auto;
        min-width: 0;
        max-width: none;
      }
      .context-panel {
        max-height: 50vh;
      }
      .top-controls {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .sequencer-wrap {
        grid-template-columns: 190px minmax(0, 1fr);
      }
      .track-strip {
        width: 190px;
        min-width: 190px;
      }
      .strip-row {
        grid-template-columns: minmax(0, 1fr) 30px 30px 30px 30px;
        gap: 3px;
      }
      .strip-mute,
      .strip-solo,
      .strip-tensor,
      .strip-tone {
        width: 30px;
        min-width: 30px;
      }
      .step-area {
        overflow-x: auto;
        overflow-y: hidden;
      }
      #sequencer .grid {
        min-width: 520px;
      }
    }

    @media (max-width: 700px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }
      h1 {
        font-size: 18px;
        letter-spacing: 1.2px;
      }
      .transport {
        width: 100%;
        gap: 6px;
      }
      .transport button {
        font-size: 12px;
        padding: 8px 10px;
      }
      .mode-switch {
        width: 100%;
        padding-left: 0;
        justify-content: flex-start;
      }
      .top-controls {
        grid-template-columns: 1fr;
      }
      .context-panel {
        max-height: 46vh;
      }
      .context-tabs {
        grid-template-columns: repeat(5, minmax(0, 1fr));
      }
      .sequencer-wrap {
        grid-template-columns: 144px minmax(0, 1fr);
        gap: 8px;
        padding: 8px;
      }
      .track-strip {
        width: 144px;
        min-width: 144px;
        gap: 8px;
      }
      .strip-row {
        grid-template-columns: minmax(0, 1fr) 24px 24px 24px 24px;
        gap: 3px;
      }
      .strip-mute,
      .strip-solo,
      .strip-tensor,
      .strip-tone {
        width: 24px;
        min-width: 24px;
      }
      .strip-tone {
        font-size: 8px;
        letter-spacing: 0.2px;
      }
      #sequencer .grid {
        min-width: 500px;
      }
      .label {
        font-size: 12px;
      }
      .mute {
        font-size: 11px;
        padding: 5px 7px;
      }
      .solo {
        font-size: 11px;
        padding: 5px 7px;
      }
      .lock-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
      }
    }

    @media (max-width: 520px) {
      .app {
        padding: 10px;
      }
      .transport {
        gap: 5px;
      }
      .transport button {
        font-size: 11px;
        padding: 7px 8px;
      }
      .tab-btn {
        font-size: 10px;
        letter-spacing: 0.5px;
        padding: 8px 4px;
      }
      .sequencer-wrap {
        grid-template-columns: 124px minmax(0, 1fr);
      }
      .track-strip {
        width: 124px;
        min-width: 124px;
      }
      .strip-row {
        grid-template-columns: minmax(0, 1fr) 20px 20px 20px 20px;
        gap: 2px;
      }
      .strip-mute,
      .strip-solo,
      .strip-tensor,
      .strip-tone {
        width: 20px;
        min-width: 20px;
      }
      .strip-tone {
        font-size: 8px;
        letter-spacing: 0.2px;
      }
      #sequencer .grid {
        min-width: 460px;
        gap: 5px;
      }
      .step {
        border-radius: 5px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>DRM MCHN — Beatdown</h1>
      <div class="transport">
        <button id="play" class="primary">Play</button>
        <button id="stop">Stop</button>
        <button id="clear" class="danger">Clear</button>
        <button id="reroll">Re-roll Feel</button>
        <button id="resampleMaster">Resample Master</button>
        <button id="record">Record</button>
        <button id="exportWav">Stop & Export WAV</button>
        <div class="mode-switch">
          <button data-mode="sketch">Sketch</button>
          <button data-mode="edit" class="active">Edit</button>
          <button data-mode="perform">Perform</button>
        </div>
        <span class="small" id="recordStatus">Idle</span>
        <span class="small">Space = Play/Pause</span>
      </div>
    </header>

    <div class="layout">
      <div class="left-col">
        <div class="top-controls">
          <div class="card" id="xyCard">
            <h3>XY Groove</h3>
            <div id="xyPad" class="xy-pad">
              <div class="xy-crosshair" id="xyCrosshair"></div>
              <div class="xy-handle" id="xyHandle"></div>
            </div>
            <div class="small">X = swing, Y = looseness</div>
          </div>
          <div class="card" id="tempoCard">
            <h3>Tempo</h3>
            <input id="tempo" type="range" min="88" max="140" value="116" />
            <input id="tempoNumber" type="number" min="88" max="140" value="116" />
            <div class="small"><span id="tempoValue">116</span> BPM</div>
          </div>
          <div class="card" id="quickSketchCard">
            <h3>Quick Sketch</h3>
            <div class="preset-row">
              <button id="sketchA">Sketch A</button>
              <button id="sketchB">Sketch B</button>
              <button id="sketchC">Sketch C</button>
            </div>
            <div class="small">A: Pocket • B: Lurch • C: Shuffle (Hotkeys 1/2/3)</div>
            <div class="sketch-controls">
              <div class="sketch-row">
                <div class="sketch-select">
                  <label for="sketchGroove">Groove</label>
                  <select id="sketchGroove">
                    <option value="random" selected>Random</option>
                    <option value="Pocket">Pocket</option>
                    <option value="Lurch">Lurch</option>
                    <option value="Swing">Swing</option>
                    <option value="Drunk">Drunk</option>
                  </select>
                </div>
                <div class="sketch-select">
                  <label for="sketchDensity">Density</label>
                  <select id="sketchDensity">
                    <option value="random" selected>Random</option>
                    <option value="Sparse">Sparse</option>
                    <option value="Medium">Medium</option>
                    <option value="Dense">Dense</option>
                  </select>
                </div>
                <div class="sketch-select">
                  <label for="sketchAccent">Accent</label>
                  <select id="sketchAccent">
                    <option value="random" selected>Random</option>
                    <option value="Downbeat">Downbeat</option>
                    <option value="Offbeat">Offbeat</option>
                    <option value="Ghosted">Ghosted</option>
                  </select>
                </div>
                <div class="sketch-select">
                  <label for="sketchHumanize">Humanize</label>
                  <select id="sketchHumanize">
                    <option value="random" selected>Random</option>
                    <option value="Mild">Mild</option>
                    <option value="Live">Live</option>
                    <option value="Chaos">Chaos</option>
                  </select>
                </div>
              </div>
              <div class="sketch-locks">
                <div class="small">Lock Tracks</div>
                <div class="lock-grid">
                  <label class="lock-pill"><input class="pill-check" type="checkbox" data-lock-track="0" /><span class="pill-label">Kick</span></label>
                  <label class="lock-pill"><input class="pill-check" type="checkbox" data-lock-track="1" /><span class="pill-label">Snare</span></label>
                  <label class="lock-pill"><input class="pill-check" type="checkbox" data-lock-track="2" /><span class="pill-label">Hat</span></label>
                  <label class="lock-pill"><input class="pill-check" type="checkbox" data-lock-track="3" /><span class="pill-label">Clap</span></label>
                  <label class="lock-pill"><input class="pill-check" type="checkbox" data-lock-track="4" /><span class="pill-label">Tom</span></label>
                  <label class="lock-pill"><input class="pill-check" type="checkbox" data-lock-track="5" /><span class="pill-label">Perc</span></label>
                  <label class="lock-pill"><input class="pill-check" type="checkbox" data-lock-track="6" /><span class="pill-label">Ride</span></label>
                  <label class="lock-pill"><input class="pill-check" type="checkbox" data-lock-track="7" /><span class="pill-label">Fx</span></label>
                </div>
              </div>
              <div class="sketch-inline">
                <div class="variation-meter" id="quickVariation"><span></span></div>
                <span class="small" id="quickVariationValue">Var 0%</span>
              </div>
              <div class="small sketch-summary" id="quickSketchSummary">Ready.</div>
            </div>
          </div>
          <div class="card" id="genreSketchCard">
            <h3>Genre Sketch</h3>
            <button id="toggleGenreSketch" class="section-toggle" aria-expanded="false" aria-controls="genreSketchBody">
              <span>Genre Tools</span><span id="genreToggleLabel">Collapsed</span>
            </button>
            <div id="genreSketchBody" class="section-body collapsed">
              <div class="preset-row">
                <button id="sketchHouse">House</button>
                <button id="sketchTechno">Techno</button>
                <button id="sketchHipHop">Hip Hop</button>
              </div>
              <div class="small">Experimental genre starters (Hotkeys 4/5/6)</div>
              <div class="sketch-controls">
                <div class="sketch-row">
                  <div class="sketch-select">
                    <label for="houseFlavor">House</label>
                    <select id="houseFlavor">
                      <option value="Deep" selected>Deep</option>
                      <option value="Jackin'">Jackin'</option>
                      <option value="Dub">Dub</option>
                      <option value="Beatdown">Beatdown</option>
                    </select>
                  </div>
                  <div class="sketch-select">
                    <label for="technoFlavor">Techno</label>
                    <select id="technoFlavor">
                      <option value="Minimal" selected>Minimal</option>
                      <option value="Industrial">Industrial</option>
                      <option value="Hypnotic">Hypnotic</option>
                    </select>
                  </div>
                  <div class="sketch-select">
                    <label for="hiphopFlavor">Hip Hop</label>
                    <select id="hiphopFlavor">
                      <option value="Boom Bap" selected>Boom Bap</option>
                      <option value="Lo-Fi">Lo-Fi</option>
                      <option value="Experimental">Experimental</option>
                    </select>
                  </div>
                  <div class="sketch-select">
                    <label>&nbsp;</label>
                    <button id="sketchSurprise" class="primary">Surprise Me</button>
                  </div>
                </div>
                <div class="sketch-inline">
                  <div class="variation-meter" id="genreVariation"><span></span></div>
                  <span class="small" id="genreVariationValue">Var 0%</span>
                </div>
                <div class="small sketch-summary" id="genreSketchSummary">Ready.</div>
                <div class="palette-panel" style="margin-top:10px;" id="palettePanel">
                  <button id="togglePalette" class="section-toggle subtle" aria-expanded="false" aria-controls="paletteBody">
                    <span>Instrument Palette (Tags)</span><span id="paletteToggleLabel">Collapsed</span>
                  </button>
                  <div id="paletteBody" class="section-body collapsed">
                    <div class="palette-list" id="paletteList"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="sequencer-wrap">
          <aside id="trackStrip" class="track-strip"></aside>
          <section class="step-area">
            <section id="sequencer"></section>
          </section>
        </div>

        <div class="bottom-controls">
          <div class="card" id="fadersCard">
            <h3>Track Faders</h3>
            <div class="faders" id="faders"></div>
          </div>
          <div class="card" id="knobsCard">
            <h3>Track Knobs</h3>
            <div class="knob-grid" id="knobs"></div>
          </div>
        </div>
      </div>
      <div class="right-col">
        <div class="card" id="swingCard">
          <h3>Swing</h3>
          <input id="swing" type="range" min="0" max="70" value="24" />
          <div class="small"><span id="swingValue">24</span> ms</div>
        </div>
        <div class="card" id="tapeCard">
          <h3>Master Tape</h3>
          <input id="tape" type="range" min="0" max="100" value="35" />
          <div class="small"><span id="tapeValue">35</span>%</div>
        </div>
        <div class="card" id="noiseCard">
          <h3>Noise Layer</h3>
          <input id="layer" type="range" min="0" max="100" value="35" />
          <div class="small"><span id="layerValue">35</span>% chance</div>
        </div>
        <div class="card" id="tensorCard">
          <h3>Tensor</h3>
          <label class="small"><input id="tensorEnable" type="checkbox" /> Enable</label>
          <div class="inline"><label>Blend</label><span class="small" id="tensorBlendValue">35%</span></div>
          <input id="tensorBlend" type="range" min="0" max="100" value="35" />
          <div class="inline"><label>Speed</label><span class="small" id="tensorSpeedValue">100%</span></div>
          <input id="tensorSpeed" type="range" min="-200" max="200" value="100" />
          <div class="inline"><label>Pitch</label><span class="small" id="tensorPitchValue">0 st</span></div>
          <input id="tensorPitch" type="range" min="-12" max="12" value="0" />
          <div class="inline"><label>Stretch</label><span class="small" id="tensorStretchValue">100%</span></div>
          <input id="tensorStretch" type="range" min="50" max="200" value="100" />
          <div class="inline"><label>Stop Time</label><span class="small" id="tensorStopValue">350 ms</span></div>
          <input id="tensorStopTime" type="range" min="50" max="2000" value="350" />
          <label for="tensorReverseMode">Reverse Mode</label>
          <select id="tensorReverseMode">
            <option value="off" selected>Off</option>
            <option value="momentary">Momentary</option>
            <option value="latch">Latch</option>
          </select>
          <div class="preset-row" style="margin-top:8px;">
            <button id="tensorReverseHold">Reverse Hold</button>
            <button id="tensorReverseLatch">Reverse Latch</button>
          </div>
          <label class="small"><input id="tensorFreeze" type="checkbox" /> Hold / Freeze</label>
          <div class="inline"><label>Loop</label><span class="small" id="tensorLoopValue">1200 ms</span></div>
          <input id="tensorLoopLength" type="range" min="250" max="9400" step="10" value="1200" />
          <div class="inline"><label>Random Slice</label><span class="small" id="tensorRandomValue">0%</span></div>
          <input id="tensorRandomAmount" type="range" min="0" max="100" value="0" />
          <div class="inline"><label>Rand Trigger</label><span class="small" id="tensorTriggerValue">20%</span></div>
          <input id="tensorRandomTrigger" type="range" min="0" max="100" value="20" />
          <div class="inline"><label>Smooth</label><span class="small" id="tensorSmoothValue">35%</span></div>
          <input id="tensorSmooth" type="range" min="0" max="100" value="35" />
          <div class="small" id="tensorStatus">Tensor idle</div>
        </div>
        <div class="card" id="humanizeCard">
          <h3>Humanize</h3>
          <select id="groovePreset">
            <option value="tight">Tight</option>
            <option value="loose" selected>Loose</option>
            <option value="live">Live MPC</option>
            <option value="theo">Theo Mode</option>
          </select>
          <div class="inline"><label>Looseness</label><span class="small" id="loosenessValue">24</span></div>
          <input id="looseness" type="range" min="0" max="40" value="24" />
          <div class="inline"><label>Vel Var</label><span class="small" id="velVarValue">18%</span></div>
          <input id="velVar" type="range" min="0" max="40" value="18" />
          <div class="inline"><label>Swing Drift</label><span class="small" id="swingVarValue">12</span></div>
          <input id="swingVar" type="range" min="0" max="30" value="12" />
          <div class="inline"><label>Pulse Drift</label><span class="small" id="pulseValue">0.6</span></div>
          <input id="pulse" type="range" min="0" max="2" step="0.1" value="0.6" />
          <div class="inline"><label>Detune</label><span class="small" id="detuneValue">1.2</span></div>
          <input id="detune" type="range" min="0" max="2" step="0.1" value="1.2" />
          <div class="inline"><label>Mod</label><span class="small" id="modValue">18%</span></div>
          <input id="mod" type="range" min="0" max="40" value="18" />
        </div>
        <div class="card" id="chaosCard">
          <h3>Max Chaos</h3>
          <input id="chaos" type="range" min="0" max="200" value="110" />
          <div class="small"><span id="chaosValue">110</span>%</div>
        </div>
        <div class="card" id="pressureCard">
          <h3>Pressure</h3>
          <input id="pressure" type="range" min="0" max="100" value="0" />
          <div class="small"><span id="pressureValue">0</span>%</div>
        </div>
        <div class="card" id="behaviorCard">
          <h3>Behavior Engine</h3>
          <div class="stress-wrap">
            <div class="stress-meter"><div class="stress-fill" id="stressFill"></div></div>
            <div class="stress-meta">
              <div class="small">System Stress</div>
              <div class="small" id="stressText">0%</div>
            </div>
          </div>
          <div class="group-label">Body</div>
          <label for="headroomMode">Headroom Coupling</label>
          <select id="headroomMode">
            <option value="off">Off</option>
            <option value="glue" selected>Glue</option>
            <option value="punch">Punch</option>
            <option value="dirt">Dirt</option>
            <option value="collapse">Collapse</option>
          </select>
          <div class="inline"><label>Coupling</label><span class="small" id="headroomAmountValue">45%</span></div>
          <input id="headroomAmount" type="range" min="0" max="100" value="45" />
          <div class="small" id="densityReactInfo">Density React 65%</div>
          <div class="small" id="sagInfo">Sag 0c</div>
          <div class="group-label">Tone</div>
          <label for="velocityCrushMode">Velocity Bit-Depth</label>
          <select id="velocityCrushMode">
            <option value="ghost_grit" selected>Ghost = Grit</option>
            <option value="accent_grit">Accent = Grit</option>
            <option value="off">Off</option>
          </select>
          <div class="group-label">Mind</div>
          <div class="inline"><label>Evolve</label><span class="small" id="evolutionAmountValue">10%</span></div>
          <input id="evolutionAmount" type="range" min="0" max="100" value="10" />
          <div class="small" id="evolutionMemoryInfo">Memory 0/4</div>
          <label class="small" style="margin-top:6px;"><input id="dryMode" type="checkbox" /> Dry Mode (Bypass FX)</label>
          <label for="fxFocus">FX Focus</label>
          <select id="fxFocus">
            <option value="none" selected>None</option>
            <option value="dist">Distortion</option>
            <option value="crush">Crusher</option>
            <option value="delay">Delay</option>
            <option value="reverb">Reverb</option>
            <option value="tensor">Tensor</option>
          </select>
          <div class="small" id="fxFocusInfo">Dry mode off</div>
        </div>
        <div class="card" id="stepEditorCard">
          <h3>Step Editor</h3>
          <div class="small" id="stepLabel">No step selected (Alt+Click a step)</div>
          <div class="inline"><label>Chance</label><span class="small" id="chanceValue">100%</span></div>
          <input id="stepChance" type="range" min="0" max="100" value="100" />
          <div class="inline"><label>Every N</label><span class="small" id="everyValue">1</span></div>
          <input id="stepEvery" type="range" min="1" max="8" value="1" />
          <div class="inline"><label>Pitch Lock</label><span class="small" id="lockPitchValue">0</span></div>
          <input id="lockPitch" type="range" min="-12" max="12" value="0" />
          <label class="small"><input id="lockPitchEnable" type="checkbox" /> Enable</label>
          <div class="inline"><label>Reverse</label><span class="small" id="lockReverseValue">Off</span></div>
          <input id="lockReverse" type="checkbox" />
          <div class="inline"><label>Slice</label><span class="small" id="lockSliceValue">0</span></div>
          <input id="lockSlice" type="range" min="0" max="15" value="0" />
          <label class="small"><input id="lockSliceEnable" type="checkbox" /> Enable</label>
          <div class="inline"><label>Stretch</label><span class="small" id="lockStretchValue">1.0</span></div>
          <input id="lockStretch" type="range" min="0.5" max="2" step="0.1" value="1" />
          <label class="small"><input id="lockStretchEnable" type="checkbox" /> Enable</label>
          <div class="inline"><label>Filter</label><span class="small" id="lockFilterValue">1200</span></div>
          <input id="lockFilter" type="range" min="300" max="8000" value="1200" />
          <label class="small"><input id="lockFilterEnable" type="checkbox" /> Enable</label>
          <div class="inline"><label>Resonance</label><span class="small" id="lockResValue">1.0</span></div>
          <input id="lockRes" type="range" min="0.1" max="12" step="0.1" value="1" />
          <label class="small"><input id="lockResEnable" type="checkbox" /> Enable</label>
          <div class="inline"><label>Decay</label><span class="small" id="lockDecayValue">0.5</span></div>
          <input id="lockDecay" type="range" min="0.1" max="1.2" step="0.05" value="0.5" />
          <label class="small"><input id="lockDecayEnable" type="checkbox" /> Enable</label>
          <div class="inline"><label>FX Mix</label><span class="small" id="lockFxValue">30%</span></div>
          <input id="lockFx" type="range" min="0" max="100" value="30" />
          <label class="small"><input id="lockFxEnable" type="checkbox" /> Enable</label>
          <button id="clearLocks">Clear Locks</button>
        </div>
      </div>
    </div>

    <section id="trackControls" class="track-controls"></section>

    <div class="hint">
      Beatdown feel: click toggles steps, Shift+Click cycles velocity, Right-click cycles microtiming (push/pull), Alt+Click selects step for locks. Humanize adds random looseness, swing drift, and subtle instability.
    </div>
  </div>

  <script>
    const tracks = [
      { name: "Kick", tone: "kick", color: "#f5c542" },
      { name: "Snare", tone: "snare", color: "#ff6b6b" },
      { name: "Hat", tone: "hat", color: "#2bd4a4" },
      { name: "Clap", tone: "clap", color: "#8f7cff" },
      { name: "Tom", tone: "tom", color: "#49b3f5" },
      { name: "Perc", tone: "perc", color: "#f59f49" },
      { name: "Ride", tone: "ride", color: "#9bd53a" },
      { name: "Fx", tone: "fx", color: "#d975f5" }
    ];

    const steps = 16;
    const ALL_STEPS = Array.from({ length: steps }, (_, i) => i);
    const microOffsets = [-30, -18, -8, 0, 8, 18, 30];

    const sequence = tracks.map(() => Array.from({ length: steps }, () => ({
      on: false,
      velocity: 0.7,
      offset: 0,
      humanOffset: 0,
      humanVel: 1.0,
      humanDetune: 0,
      humanMod: 0,
      cond: { chance: 100, every: 1 },
      locks: {
        pitch: null,
        reverse: null,
        stretch: null,
        slice: null,
        filter: null,
        resonance: null,
        decay: null,
        fx: null
      }
    })));

    const trackState = tracks.map(() => ({
      mute: false,
      solo: false,
      tensorEnabled: false,
      cycle: 16,
      stutter: 0.25,
      source: "sample",
      buffer: null,
      reverseBuffer: null,
      resampleBuffer: null,
      liveNode: null,
      liveGain: null,
      trackOut: null,
      fxNodes: null,
      volume: 0.8,
      pitch: 0,
      decay: 0.5,
      stretch: 1,
      slice: 0,
      filter: 1200,
      resonance: 1.0,
      crush: 0.0,
      dist: 0.2,
      delay: 0.2,
      reverb: 0.2,
      fx: 0.3,
      lfo: 0.0
      ,
      style: "lofi"
    }));

    const trackLoopCount = tracks.map(() => 0);

    const humanize = {
      looseness: 24,
      velocityVar: 0.18,
      swingVar: 12,
      pulseDrift: 0.6,
      detune: 1.2,
      mod: 0.18
    };
    const groovePresets = {
      tight: { looseness: 8, velocityVar: 0.08, swingVar: 5, pulseDrift: 0.2, detune: 0.4, mod: 0.08 },
      loose: { looseness: 24, velocityVar: 0.18, swingVar: 12, pulseDrift: 0.6, detune: 1.2, mod: 0.18 },
      live: { looseness: 28, velocityVar: 0.22, swingVar: 18, pulseDrift: 0.9, detune: 1.4, mod: 0.22 },
      theo: { looseness: 36, velocityVar: 0.3, swingVar: 24, pulseDrift: 1.3, detune: 1.8, mod: 0.3 }
    };

    const SKETCH_PARAMS = {
      groove: ["Pocket", "Lurch", "Swing", "Drunk"],
      density: ["Sparse", "Medium", "Dense"],
      accent: ["Downbeat", "Offbeat", "Ghosted"],
      humanize: ["Mild", "Live", "Chaos"]
    };

    const GENRE_FLAVORS = {
      House: ["Deep", "Jackin'", "Dub", "Beatdown"],
      Techno: ["Minimal", "Industrial", "Hypnotic"],
      HipHop: ["Boom Bap", "Lo-Fi", "Experimental"]
    };

    const INSTRUMENT_PALETTE = [
      { name: "Triangle", tag: "High Perc" },
      { name: "Woodblock", tag: "Hit Snap" },
      { name: "Kettle Drum", tag: "Tuned Low" },
      { name: "Conga", tag: "Tuned Mid" },
      { name: "Bongo", tag: "Tuned High" },
      { name: "Shaker", tag: "Texture" },
      { name: "Cowbell", tag: "Lead Perc" },
      { name: "Bell Tree", tag: "Accent FX" },
      { name: "Tabla Daya", tag: "Tuned Mod" },
      { name: "Tabla Baya", tag: "Tuned Mod" }
    ];

    const sketchLocks = new Set();
    let lastSketchName = "";

    // ===== Character Filter Bus =====
    let characterEnabled = true;
    let characterPreGain, characterPostGain;
    let characterFilter1, characterFilter2;
    let energyAnalyser, energyData, energyTimerId = null;

    let characterBaseCutoff = 800;
    let characterBaseQ = 0.9;
    let characterBaseDrive = 1.0;

    let characterEnvAmount = 2500;
    let characterEnvAttack = 0.004;
    let characterEnvDecay = 0.11;

    let characterJitterAmount = 0.01;
    let lastJitter = 1.0;

    let characterDriveEnvAmount = 0.25;
    let characterDriveEnvDecay = 0.1;

    let energyModEnabled = true;
    let energyModDepthHz = 90;
    let energyModSmooth = 0.85;
    let energyValue = 0.0;
    let energyUpdateHz = 30;

    let hfDampAmount = 0.18;
    let hfDampStartQ = 6.0;

    // ===== Pressure Macro =====
    let pressureAmount = 0.0;
    const baseNoiseLayer = 0.35;

    // ===== Behavior Engine =====
    let headroomModeValue = "glue";
    let headroomAmountValueNum = 0.45;
    let velocityCrushModeValue = "ghost_grit";
    let dryModeEnabled = false;
    let fxFocusEffect = "none";
    let evolutionAmount = 0.10;
    let transientAccentBoost = 0.0;
    let previousStepLoad = 0.0;
    let longDrift = 0;
    const densityReactAmount = 0.65;
    let kickTransientBoost = 1.0;
    let preSaturationDrive = 1.0;
    // ===== Stress / Heat State (0..1) =====
    const behavior = {
      // inputs (smoothed)
      energy: 0,    // 0..1 (you already compute energyValue elsewhere)
      density: 0,   // 0..1 (hits this step, smoothed)
      cluster: 0,   // 0..1 (tight hit spacing, smoothed)
      impulse: 0,   // 0..1 (max accent / transient shock)

      // user controls
      pressure: 0,  // 0..1 (mapped from slider)

      // state
      stress: 0,    // 0..1 fast
      heat: 0,      // 0..1 slow

      // derived outputs (consume anywhere)
      timingTighten: 0,  // 0..1
      envScale: 1,       // multiplier
      driveScale: 1,     // multiplier
      noiseBoost: 0,     // additive gain
      sagCents: 0,       // negative cents
      cutoffDroopHz: 0,  // negative Hz
      hfDampBoost: 0     // additive damping amount
    };
    const evolutionMemory = [];
    const evolutionMemoryLimit = 4;
    const tensorState = {
      enabled: false,
      blend: 0.35,
      speed: 1.0,
      pitchSemitones: 0,
      stretch: 1.0,
      stopTimeMs: 350,
      reverseMode: "off",
      reverseHeld: false,
      reverseLatched: false,
      freeze: false,
      loopMs: 1200,
      randomAmount: 0,
      randomTrigger: 0.2,
      smooth: 0.35,
      writePos: 0,
      readPos: 0,
      currentSpeed: 1.0,
      pitchPhase: 0,
      bufferLen: 0,
      sampleRate: 48000,
      left: null,
      right: null,
      crossfadeSamples: 256,
      crossfadeRemaining: 0,
      prevReadPos: 0
    };

    // Pattern banks for sketch variety.
    const POCKET_KICKS = [
      [0, 6, 10, 12],
      [0, 5, 9, 12],
      [0, 6, 8, 12],
      [0, 7, 10, 13],
      [0, 6, 11, 14],
      [0, 8, 10, 12]
    ];
    const POCKET_SNARES = [
      [4, 12],
      [4, 12, 15],
      [4, 11]
    ];
    const POCKET_GHOSTS = [
      [3, 7, 15],
      [2, 10, 14],
      [3, 9],
      [6, 14]
    ];
    const POCKET_PERC = [
      [11],
      [9, 14],
      [5, 13],
      [7]
    ];

    const LURCH_KICKS = [
      [0, 5, 9, 13],
      [0, 6, 9, 14],
      [0, 7, 11, 13],
      [0, 5, 10, 14],
      [0, 6, 10, 13],
      [0, 7, 10, 15]
    ];
    const LURCH_SNARES = [
      [4, 12],
      [4, 12, 15],
      [4, 11, 12]
    ];
    const LURCH_GHOSTS = [
      [3, 7, 11, 15],
      [2, 6, 10, 15],
      [3, 9, 14],
      [6, 10, 15]
    ];
    const LURCH_PERC = [
      [5, 11],
      [6, 10],
      [7, 13],
      [2, 14]
    ];

    const SHUFFLE_KICKS = [
      [0, 7, 11, 14],
      [0, 6, 11, 15],
      [0, 8, 12, 15],
      [0, 7, 12, 14],
      [0, 5, 11, 15],
      [0, 6, 12, 14]
    ];
    const SHUFFLE_SNARES = [
      [4, 12, 15],
      [4, 12],
      [4, 12, 14]
    ];
    const SHUFFLE_GHOSTS = [
      [6, 9],
      [7, 10],
      [5, 11],
      [6, 12]
    ];
    const SHUFFLE_PERC = [
      [5],
      [13],
      [9],
      [7, 14]
    ];
    const SHUFFLE_RIDE = [
      [2, 10],
      [3, 11],
      [1, 9]
    ];
    const HOUSE_KICKS = [
      [0, 4, 8, 12],
      [0, 4, 8, 12, 15],
      [0, 4, 7, 8, 12]
    ];
    const HOUSE_SNARES = [
      [4, 12],
      [4, 12, 14]
    ];
    const TECHNO_KICKS = [
      [0, 4, 8, 12],
      [0, 4, 8, 12, 14],
      [0, 4, 8, 11, 12]
    ];
    const TECHNO_SNARES = [
      [4, 12],
      [4, 12, 15]
    ];
    const HIPHOP_KICKS = [
      [0, 7, 10, 13],
      [0, 6, 9, 13],
      [0, 5, 8, 12, 14]
    ];
    const HIPHOP_SNARES = [
      [4, 12],
      [4, 12, 15]
    ];
    const HIPHOP_GHOSTS = [
      [3, 6, 14],
      [2, 7, 10, 14],
      [3, 9, 15]
    ];

    const sequencer = document.getElementById("sequencer");
    const trackStrip = document.getElementById("trackStrip");
    const trackControls = document.getElementById("trackControls");
    const faders = document.getElementById("faders");
    const knobs = document.getElementById("knobs");

    function buildGrid() {
      sequencer.innerHTML = "";
      if (trackStrip) trackStrip.innerHTML = "";
      tracks.forEach((track, tIndex) => {
        const stripRow = document.createElement("div");
        stripRow.className = "strip-row";
        stripRow.dataset.rowIndex = String(tIndex);

        const label = document.createElement("div");
        label.className = "label strip-name";
        label.textContent = track.name;
        stripRow.appendChild(label);
        stripRow.addEventListener("click", () => setSelectedTrack(tIndex));

        const grid = document.createElement("div");
        grid.className = "grid";

        for (let s = 0; s < steps; s++) {
          const step = document.createElement("button");
          step.className = "step";
          step.dataset.track = tIndex;
          step.dataset.step = s;
          step.dataset.vel = "";

          step.addEventListener("click", (event) => toggleStep(event, tIndex, s, step));
          step.addEventListener("contextmenu", (event) => tweakMicroTiming(event, tIndex, s, step));
          grid.appendChild(step);
        }

        const seqRow = document.createElement("div");
        seqRow.className = "seq-row";
        seqRow.dataset.rowIndex = String(tIndex);
        seqRow.appendChild(grid);

        const mute = document.createElement("button");
        mute.className = "mute channel-btn strip-mute";
        mute.classList.toggle("active", trackState[tIndex].mute);
        mute.textContent = trackState[tIndex].mute ? "Muted" : "Mute";
        mute.addEventListener("click", (event) => {
          event.stopPropagation();
          trackState[tIndex].mute = !trackState[tIndex].mute;
          mute.classList.toggle("active", trackState[tIndex].mute);
          mute.textContent = trackState[tIndex].mute ? "Muted" : "Mute";
        });
        stripRow.appendChild(mute);

        const solo = document.createElement("button");
        solo.className = "solo channel-btn strip-solo";
        solo.classList.toggle("active", trackState[tIndex].solo);
        solo.textContent = "Solo";
        solo.addEventListener("click", (event) => {
          event.stopPropagation();
          trackState[tIndex].solo = !trackState[tIndex].solo;
          solo.classList.toggle("active", trackState[tIndex].solo);
          updateSoloVisuals();
        });
        stripRow.appendChild(solo);

        const tensorToggle = document.createElement("button");
        tensorToggle.className = "tensor-toggle channel-btn strip-tensor";
        tensorToggle.classList.toggle("active", trackState[tIndex].tensorEnabled);
        tensorToggle.textContent = "T";
        tensorToggle.addEventListener("click", (event) => {
          event.stopPropagation();
          trackState[tIndex].tensorEnabled = !trackState[tIndex].tensorEnabled;
          tensorToggle.classList.toggle("active", trackState[tIndex].tensorEnabled);
          updateTensorStatus();
        });
        stripRow.appendChild(tensorToggle);

        const colorTag = document.createElement("div");
        colorTag.className = "label strip-tone";
        colorTag.style.color = track.color;
        colorTag.textContent = track.tone.toUpperCase();
        stripRow.appendChild(colorTag);

        if (trackStrip) trackStrip.appendChild(stripRow);
        sequencer.appendChild(seqRow);
      });
      lockSequencerRowHeights();
      requestAnimationFrame(lockSequencerRowHeights);
      updateSoloVisuals();
    }

    function lockSequencerRowHeights() {
      if (!trackStrip || !sequencer) return;
      const stripRows = trackStrip.querySelectorAll(".strip-row");
      const seqRows = sequencer.querySelectorAll(".seq-row");
      const count = Math.min(stripRows.length, seqRows.length);
      for (let i = 0; i < count; i++) {
        const a = stripRows[i];
        const b = seqRows[i];
        a.style.height = "";
        b.style.height = "";
        const height = Math.max(a.offsetHeight, b.offsetHeight, 42);
        const px = `${height}px`;
        a.style.height = px;
        b.style.height = px;
      }
    }

    function buildTrackControls() {
      trackControls.innerHTML = "";
      tracks.forEach((track, tIndex) => {
        const card = document.createElement("div");
        card.className = "track-card";
        card.innerHTML = `
          <h4>${track.name} Tone</h4>
          <div class="inline"><label>Source</label><span class="small" id="sourceVal-${tIndex}">Sample</span></div>
          <select data-track="${tIndex}" data-param="source">
            <option value="sample">Sample</option>
            <option value="live">Live</option>
            <option value="resample">Resample</option>
          </select>
          <div class="inline"><label>Style</label><span class="small" id="styleVal-${tIndex}">Lo-fi</span></div>
          <select data-track="${tIndex}" data-param="style">
            <option value="lofi">Lo-fi</option>
            <option value="metallic">Metallic</option>
            <option value="dirty">Dirty</option>
            <option value="soft">Soft</option>
            <option value="random">Random</option>
          </select>
          <input data-track="${tIndex}" data-param="sample" type="file" accept="audio/*" />
          <button data-track="${tIndex}" data-param="resample">Resample Track</button>
          <div class="inline"><label>Pitch</label><span class="small" id="pitchVal-${tIndex}">0</span></div>
          <input data-track="${tIndex}" data-param="pitch" type="range" min="-12" max="12" value="0" />
          <div class="inline"><label>Decay</label><span class="small" id="decayVal-${tIndex}">50%</span></div>
          <input data-track="${tIndex}" data-param="decay" type="range" min="10" max="100" value="50" />
          <div class="inline"><label>Stretch</label><span class="small" id="stretchVal-${tIndex}">1.0</span></div>
          <input data-track="${tIndex}" data-param="stretch" type="range" min="0.5" max="2" step="0.1" value="1" />
          <div class="inline"><label>Slice</label><span class="small" id="sliceVal-${tIndex}">0</span></div>
          <input data-track="${tIndex}" data-param="slice" type="range" min="0" max="15" value="0" />
          <div class="inline"><label>Filter</label><span class="small" id="filterVal-${tIndex}">1200</span></div>
          <input data-track="${tIndex}" data-param="filter" type="range" min="300" max="8000" value="1200" />
          <div class="inline"><label>Resonance</label><span class="small" id="resVal-${tIndex}">1.0</span></div>
          <input data-track="${tIndex}" data-param="res" type="range" min="0.1" max="12" step="0.1" value="1" />
          <div class="inline"><label>Bit Crush</label><span class="small" id="crushVal-${tIndex}">0%</span></div>
          <input data-track="${tIndex}" data-param="crush" type="range" min="0" max="100" value="0" />
          <div class="inline"><label>Dist</label><span class="small" id="distVal-${tIndex}">20%</span></div>
          <input data-track="${tIndex}" data-param="dist" type="range" min="0" max="100" value="20" />
          <div class="inline"><label>Delay</label><span class="small" id="delayVal-${tIndex}">20%</span></div>
          <input data-track="${tIndex}" data-param="delay" type="range" min="0" max="100" value="20" />
          <div class="inline"><label>Reverb</label><span class="small" id="reverbVal-${tIndex}">20%</span></div>
          <input data-track="${tIndex}" data-param="reverb" type="range" min="0" max="100" value="20" />
          <div class="inline"><label>FX Mix</label><span class="small" id="fxVal-${tIndex}">30%</span></div>
          <input data-track="${tIndex}" data-param="fx" type="range" min="0" max="100" value="30" />
          <div class="inline"><label>LFO</label><span class="small" id="lfoVal-${tIndex}">0%</span></div>
          <input data-track="${tIndex}" data-param="lfo" type="range" min="0" max="100" value="0" />
          <div class="inline"><label>Cycle</label><span class="small" id="cycleVal-${tIndex}">16</span></div>
          <input data-track="${tIndex}" data-param="cycle" type="range" min="8" max="16" value="16" />
          <div class="inline"><label>Stutter</label><span class="small" id="stutterVal-${tIndex}">25%</span></div>
          <input data-track="${tIndex}" data-param="stutter" type="range" min="0" max="100" value="25" />
        `;
        trackControls.appendChild(card);
      });
    }

    function buildFaders() {
      faders.innerHTML = "";
      tracks.forEach((track, tIndex) => {
        const wrap = document.createElement("div");
        wrap.className = "fader";
        wrap.innerHTML = `
          <div>${track.name}</div>
          <input data-track="${tIndex}" data-param="volume" type="range" min="0" max="100" value="80" />
          <div class="small" id="volVal-${tIndex}">80%</div>
        `;
        faders.appendChild(wrap);
      });
    }

    function buildKnobs() {
      knobs.innerHTML = "";
      tracks.forEach((track, tIndex) => {
        const wrap = document.createElement("div");
        wrap.className = "knob";
        wrap.innerHTML = `
          <div class="small">${track.name}</div>
          <div class="knob-visual" id="knobPitchVis-${tIndex}"></div>
          <input data-track="${tIndex}" data-param="pitch" type="range" min="-12" max="12" value="0" />
          <div class="small">Pitch</div>

          <div class="knob-visual" id="knobFilterVis-${tIndex}"></div>
          <input data-track="${tIndex}" data-param="filter" type="range" min="300" max="8000" value="1200" />
          <div class="small">Filter</div>

          <div class="knob-visual" id="knobDecayVis-${tIndex}"></div>
          <input data-track="${tIndex}" data-param="decay" type="range" min="10" max="100" value="50" />
          <div class="small">Decay</div>
        `;
        knobs.appendChild(wrap);
      });
    }

    function updateTrackParam(trackIndex, param, value) {
      const state = trackState[trackIndex];
      if (param === "pitch") state.pitch = Number(value);
      if (param === "decay") state.decay = Number(value) / 100;
      if (param === "volume") {
        state.volume = Number(value) / 100;
        if (state.trackOut) state.trackOut.gain.value = state.volume;
      }
      if (param === "stretch") state.stretch = Number(value);
      if (param === "slice") state.slice = Number(value);
      if (param === "filter") state.filter = Number(value);
      if (param === "res") state.resonance = Number(value);
      if (param === "crush") state.crush = Number(value) / 100;
      if (param === "dist") state.dist = Number(value) / 100;
      if (param === "delay") state.delay = Number(value) / 100;
      if (param === "reverb") state.reverb = Number(value) / 100;
      if (param === "fx") state.fx = Number(value) / 100;
      if (param === "lfo") state.lfo = Number(value) / 100;
      if (param === "style") state.style = value;
      if (param === "cycle") state.cycle = Math.round(Number(value));
      if (param === "stutter") state.stutter = Number(value) / 100;
      if (param === "source") {
        state.source = value;
        const label = document.getElementById(`sourceVal-${trackIndex}`);
        if (label) label.textContent = value.charAt(0).toUpperCase() + value.slice(1);
      }
      if (param === "style") {
        const label = document.getElementById(`styleVal-${trackIndex}`);
        if (label) {
          const pretty = value === "lofi" ? "Lo-fi" : value.charAt(0).toUpperCase() + value.slice(1);
          label.textContent = pretty;
        }
      }

      const map = {
        pitch: `pitchVal-${trackIndex}`,
        decay: `decayVal-${trackIndex}`,
        stretch: `stretchVal-${trackIndex}`,
        slice: `sliceVal-${trackIndex}`,
        filter: `filterVal-${trackIndex}`,
        res: `resVal-${trackIndex}`,
        crush: `crushVal-${trackIndex}`,
        dist: `distVal-${trackIndex}`,
        delay: `delayVal-${trackIndex}`,
        reverb: `reverbVal-${trackIndex}`,
        fx: `fxVal-${trackIndex}`,
        lfo: `lfoVal-${trackIndex}`,
        cycle: `cycleVal-${trackIndex}`,
        stutter: `stutterVal-${trackIndex}`
        ,
        volume: `volVal-${trackIndex}`
      };

      const el = document.getElementById(map[param]);
      if (!el) return;
      if (param === "pitch") el.textContent = value;
      if (param === "decay") el.textContent = `${value}%`;
      if (param === "stretch") el.textContent = Number(value).toFixed(1);
      if (param === "slice") el.textContent = value;
      if (param === "filter") el.textContent = value;
      if (param === "res") el.textContent = Number(value).toFixed(1);
      if (param === "crush") el.textContent = `${value}%`;
      if (param === "dist") el.textContent = `${value}%`;
      if (param === "delay") el.textContent = `${value}%`;
      if (param === "reverb") el.textContent = `${value}%`;
      if (param === "fx") el.textContent = `${value}%`;
      if (param === "lfo") el.textContent = `${value}%`;
      if (param === "cycle") el.textContent = value;
      if (param === "stutter") el.textContent = `${value}%`;
      if (param === "volume") el.textContent = `${value}%`;
    }

    function toggleStep(event, trackIndex, stepIndex, element) {
      if (event.altKey) {
        selectStep(trackIndex, stepIndex);
        return;
      }
      setSelectedTrack(trackIndex);
      const step = sequence[trackIndex][stepIndex];
      if (event.shiftKey) {
        // Beatdown velocity variation: shift-click cycles velocity per step.
        step.velocity = Number((step.velocity + 0.15).toFixed(2));
        if (step.velocity > 1.05) step.velocity = 0.35;
        element.dataset.vel = step.velocity.toFixed(2);
        return;
      }
      step.on = !step.on;
      step.velocity = step.velocity || 0.7;
      element.classList.toggle("on", step.on);
      element.dataset.vel = step.on ? step.velocity.toFixed(2) : "";
      applyStepVisuals(step, element);
      element.classList.remove("pulse");
      requestAnimationFrame(() => element.classList.add("pulse"));
    }

    function tweakMicroTiming(event, trackIndex, stepIndex, element) {
      event.preventDefault();
      const step = sequence[trackIndex][stepIndex];
      const currentIndex = microOffsets.indexOf(step.offset);
      const nextIndex = (currentIndex + 1) % microOffsets.length;
      step.offset = microOffsets[nextIndex];
      // Visualize microtiming by nudging the step horizontally.
      applyStepVisuals(step, element);
    }

    function applyHumanizePreset(name) {
      const preset = groovePresets[name];
      if (!preset) return;
      humanize.looseness = preset.looseness;
      humanize.velocityVar = preset.velocityVar;
      humanize.swingVar = preset.swingVar;
      humanize.pulseDrift = preset.pulseDrift;
      humanize.detune = preset.detune;
      humanize.mod = preset.mod;
      updateHumanizeUI();
      rollHumanizeForAllSteps();
    }

    function getStyleProfile(style) {
      if (style === "metallic") return { filter: 0.35, res: 0.6, dist: 0.05, crush: 0.05, delay: 0.2, reverb: 0.15, fx: 0.2, lfo: 0.25, decay: -0.05 };
      if (style === "dirty") return { filter: -0.25, res: 0.2, dist: 0.35, crush: 0.35, delay: 0.1, reverb: 0.05, fx: 0.25, lfo: 0.2, decay: 0.05 };
      if (style === "soft") return { filter: -0.2, res: -0.1, dist: -0.25, crush: -0.3, delay: 0.1, reverb: 0.35, fx: 0.2, lfo: 0.1, decay: 0.2 };
      return { filter: -0.1, res: 0.1, dist: -0.05, crush: 0.15, delay: 0.05, reverb: 0.1, fx: 0.1, lfo: 0.1, decay: 0.05 };
    }

    function updateHumanizeUI() {
      looseness.value = humanize.looseness;
      velVar.value = Math.round(humanize.velocityVar * 100);
      swingVar.value = humanize.swingVar;
      pulse.value = humanize.pulseDrift;
      detune.value = humanize.detune;
      mod.value = Math.round(humanize.mod * 100);
      loosenessValue.textContent = humanize.looseness;
      velVarValue.textContent = `${Math.round(humanize.velocityVar * 100)}%`;
      swingVarValue.textContent = humanize.swingVar;
      pulseValue.textContent = humanize.pulseDrift.toFixed(1);
      detuneValue.textContent = humanize.detune.toFixed(1);
      modValue.textContent = `${Math.round(humanize.mod * 100)}%`;
    }

    function rollHumanizeForStep(step) {
      const chaosScale = chaosAmount("timing");
      const densityTighten = clamp01(densityReactAmount * behavior.density);
      const loosenessNow = humanize.looseness * (1 - 0.6 * densityTighten);
      const velocityVarNow = humanize.velocityVar * (1 - 0.4 * densityTighten);
      step.humanOffset = randomInRange(-loosenessNow * chaosScale, loosenessNow * chaosScale);
      step.humanVel = 1 + randomInRange(-velocityVarNow * chaosScale, velocityVarNow * chaosScale);
      step.humanDetune = randomInRange(-humanize.detune * chaosScale, humanize.detune * chaosScale);
      step.humanMod = randomInRange(-humanize.mod * chaosScale, humanize.mod * chaosScale);
    }

    function rollHumanizeForAllSteps() {
      sequence.forEach((row) => row.forEach((step) => rollHumanizeForStep(step)));
      refreshHumanizeVisuals();
    }

    function applyStepVisuals(step, el) {
      const totalOffset = step.offset + step.humanOffset;
      const humanOpacity = clamp(0.7 + (step.humanVel - 1) * 0.6, 0.55, 1);
      el.style.transform = `translateX(${totalOffset / 4}px)`;
      el.style.opacity = step.on ? humanOpacity : 0.7;
    }

    function refreshHumanizeVisuals() {
      sequence.forEach((row, rowIndex) => {
        row.forEach((step, stepIndex) => {
          const el = document.querySelector(`.step[data-track="${rowIndex}"][data-step="${stepIndex}"]`);
          applyStepVisuals(step, el);
        });
      });
    }

    function updateTrackFocus() {
      const hasFocus = Number.isInteger(selectedTrackIndex);
      if (trackStrip) trackStrip.classList.toggle("focus-active", hasFocus);
      sequencer.classList.toggle("focus-active", hasFocus);
      document.querySelectorAll(".strip-row").forEach((row) => {
        row.classList.toggle("is-selected", Number(row.dataset.rowIndex) === selectedTrackIndex);
      });
      document.querySelectorAll(".seq-row").forEach((row) => {
        row.classList.toggle("is-selected", Number(row.dataset.rowIndex) === selectedTrackIndex);
      });
    }

    function updateSoloVisuals() {
      const hasSolo = trackState.some((state) => state.solo);
      document.querySelectorAll(".strip-row").forEach((row) => {
        const idx = Number(row.dataset.rowIndex);
        const mutedBySolo = hasSolo && !trackState[idx].solo;
        row.classList.toggle("solo-muted", mutedBySolo);
      });
      document.querySelectorAll(".seq-row").forEach((row) => {
        const idx = Number(row.dataset.rowIndex);
        const mutedBySolo = hasSolo && !trackState[idx].solo;
        row.classList.toggle("solo-muted", mutedBySolo);
      });
    }

    function setSelectedTrack(trackIndex) {
      selectedTrackIndex = trackIndex;
      updateTrackFocus();
      if (!selectedStep && stepLabel && tracks[trackIndex]) {
        stepLabel.textContent = `${tracks[trackIndex].name} (T${trackIndex + 1}) • No step selected (Alt+Click a step)`;
      }
    }

    function selectStep(trackIndex, stepIndex) {
      selectedStep = { trackIndex, stepIndex };
      setSelectedTrack(trackIndex);
      document.querySelectorAll(".step.selected").forEach((el) => el.classList.remove("selected"));
      const selectedEl = document.querySelector(`.step[data-track="${trackIndex}"][data-step="${stepIndex}"]`);
      if (selectedEl) selectedEl.classList.add("selected");
      const step = sequence[trackIndex][stepIndex];
      stepLabel.textContent = `${tracks[trackIndex].name} (T${trackIndex + 1}) • Step ${stepIndex + 1}`;
      stepChance.value = step.cond.chance;
      stepEvery.value = step.cond.every;
      chanceValue.textContent = `${step.cond.chance}%`;
      everyValue.textContent = step.cond.every;

      lockPitch.value = step.locks.pitch ?? trackState[trackIndex].pitch;
      lockPitchEnable.checked = step.locks.pitch !== null;
      lockPitchValue.textContent = lockPitch.value;

      lockReverse.checked = step.locks.reverse === true;
      lockReverseValue.textContent = lockReverse.checked ? "On" : "Off";

      lockSlice.value = step.locks.slice ?? trackState[trackIndex].slice;
      lockSliceEnable.checked = step.locks.slice !== null;
      lockSliceValue.textContent = lockSlice.value;

      lockStretch.value = step.locks.stretch ?? trackState[trackIndex].stretch;
      lockStretchEnable.checked = step.locks.stretch !== null;
      lockStretchValue.textContent = Number(lockStretch.value).toFixed(1);

      lockFilter.value = step.locks.filter ?? trackState[trackIndex].filter;
      lockFilterEnable.checked = step.locks.filter !== null;
      lockFilterValue.textContent = lockFilter.value;

      lockRes.value = step.locks.resonance ?? trackState[trackIndex].resonance;
      lockResEnable.checked = step.locks.resonance !== null;
      lockResValue.textContent = Number(lockRes.value).toFixed(1);

      lockDecay.value = step.locks.decay ?? trackState[trackIndex].decay;
      lockDecayEnable.checked = step.locks.decay !== null;
      lockDecayValue.textContent = Number(lockDecay.value).toFixed(2);

      lockFx.value = step.locks.fx ?? trackState[trackIndex].fx * 100;
      lockFxEnable.checked = step.locks.fx !== null;
      lockFxValue.textContent = `${lockFx.value}%`;
    }

    function updateSelectedStepLock(param, value, enabled) {
      if (!selectedStep) return;
      const { trackIndex, stepIndex } = selectedStep;
      const step = sequence[trackIndex][stepIndex];
      step.locks[param] = enabled ? value : null;
    }
    function resetSequence() {
      sequence.forEach((row, tIndex) => row.forEach((step) => {
        if (sketchLocks.has(tIndex)) return;
        step.on = false;
        step.velocity = 0.7;
        step.offset = 0;
        step.cond = { chance: 100, every: 1 };
        step.locks = { pitch: null, reverse: null, stretch: null, slice: null, filter: null, resonance: null, decay: null, fx: null };
        rollHumanizeForStep(step);
      }));
      document.querySelectorAll(".step").forEach((step) => {
        step.classList.remove("on");
        step.classList.remove("selected");
        step.dataset.vel = "";
        step.style.transform = "";
        step.style.opacity = "";
      });
    }

    function sketchPocket() {
      setSketchActive("sketchA");
      resetSequence();
      const params = getSketchParams();
      const density = params.density === "Sparse" ? 0.35 : params.density === "Dense" ? 0.7 : 0.5;
      const accentProb = params.accent === "Offbeat" ? 0.25 : params.accent === "Ghosted" ? 0.12 : 0.18;
      // Pocket: deep low-end with subtle ghost snare.
      const kicks = mutatePattern(pickVariant(POCKET_KICKS), 2, [0, 2, 3, 5, 6, 8, 9, 10, 12, 14, 15]);
      const snares = mutatePattern(pickVariant(POCKET_SNARES), 1, [4, 11, 12, 15]);
      const ghosts = mutatePattern(pickVariant(POCKET_GHOSTS), 2, [2, 3, 6, 7, 9, 10, 14, 15]);
      fillKickPattern(kicks);
      fillSnarePattern(snares);
      fillGhosts(1, ghosts, 0.42);
      fillHatPattern(density);
      fillPercPattern(pickVariant(POCKET_PERC));
      addHatAccentOverlay(accentProb);
      pushSketchVariation(0.35);
      finalizeSketch("Sketch A", params, 0.35, quickSketchSummary, quickVariation, quickVariationValue);
    }

    function sketchLurch() {
      setSketchActive("sketchB");
      resetSequence();
      const params = getSketchParams();
      const density = params.density === "Sparse" ? 0.3 : params.density === "Dense" ? 0.68 : 0.48;
      const accentProb = params.accent === "Offbeat" ? 0.28 : params.accent === "Ghosted" ? 0.14 : 0.2;
      // Lurch: offbeat kicks, broken hats, more ghost activity.
      const kicks = mutatePattern(pickVariant(LURCH_KICKS), 3, [0, 2, 5, 6, 7, 9, 10, 13, 14, 15]);
      const snares = mutatePattern(pickVariant(LURCH_SNARES), 2, [4, 11, 12, 15]);
      const ghosts = mutatePattern(pickVariant(LURCH_GHOSTS), 3, [2, 3, 6, 7, 9, 10, 11, 14, 15]);
      fillKickPattern(kicks);
      fillSnarePattern(snares);
      fillGhosts(1, ghosts, 0.38);
      fillHatPattern(density);
      fillPercPattern(pickVariant(LURCH_PERC));
      addHatAccentOverlay(accentProb);
      pushSketchVariation(0.4);
      finalizeSketch("Sketch B", params, 0.4, quickSketchSummary, quickVariation, quickVariationValue);
    }

    function sketchShuffle() {
      setSketchActive("sketchC");
      resetSequence();
      const params = getSketchParams();
      const density = params.density === "Sparse" ? 0.32 : params.density === "Dense" ? 0.72 : 0.52;
      const accentProb = params.accent === "Offbeat" ? 0.3 : params.accent === "Ghosted" ? 0.12 : 0.18;
      // Shuffle: sparse kicks, busier top, shifted accents.
      const kicks = mutatePattern(pickVariant(SHUFFLE_KICKS), 2, [0, 2, 5, 6, 7, 8, 11, 12, 14, 15]);
      const snares = mutatePattern(pickVariant(SHUFFLE_SNARES), 1, [4, 12, 15]);
      const ghosts = mutatePattern(pickVariant(SHUFFLE_GHOSTS), 2, [5, 6, 7, 9, 10, 11, 12]);
      fillKickPattern(kicks);
      fillSnarePattern(snares);
      fillGhosts(1, ghosts, 0.38);
      fillHatPattern(density);
      fillRidePattern(pickVariant(SHUFFLE_RIDE));
      fillPercPattern(pickVariant(SHUFFLE_PERC));
      addHatAccentOverlay(accentProb);
      pushSketchVariation(0.35);
      finalizeSketch("Sketch C", params, 0.35, quickSketchSummary, quickVariation, quickVariationValue);
    }

    function sketchHouse() {
      setSketchActive("sketchHouse");
      resetSequence();
      const params = getSketchParams();
      const density = params.density === "Sparse" ? 0.35 : params.density === "Dense" ? 0.7 : 0.5;
      const accentProb = params.accent === "Offbeat" ? 0.22 : params.accent === "Ghosted" ? 0.1 : 0.16;
      // House: four-on-the-floor with offbeat hats.
      const kicks = mutatePattern(pickVariant(HOUSE_KICKS), 1, [0, 4, 7, 8, 12, 15]);
      const snares = mutatePattern(pickVariant(HOUSE_SNARES), 1, [4, 12, 14]);
      fillKickPattern(kicks);
      fillSnarePattern(snares);
      [2, 6, 10, 14].forEach((s) => activateStep(2, s, density));
      fillHatPattern(density);
      fillPercPattern([7, 11]);
      addHatAccentOverlay(accentProb);
      pushSketchVariation(0.45);
      finalizeSketch(`House ${houseFlavor ? houseFlavor.value : ""}`.trim(), params, 0.45, genreSketchSummary, genreVariation, genreVariationValue);
    }

    function sketchTechno() {
      setSketchActive("sketchTechno");
      resetSequence();
      const params = getSketchParams();
      const density = params.density === "Sparse" ? 0.35 : params.density === "Dense" ? 0.75 : 0.55;
      const accentProb = params.accent === "Offbeat" ? 0.24 : params.accent === "Ghosted" ? 0.1 : 0.16;
      // Techno: rigid kicks, driving hats, sparse perc.
      const kicks = mutatePattern(pickVariant(TECHNO_KICKS), 1, [0, 4, 8, 11, 12, 14, 15]);
      const snares = mutatePattern(pickVariant(TECHNO_SNARES), 1, [4, 12, 15]);
      fillKickPattern(kicks);
      fillSnarePattern(snares);
      for (let i = 0; i < steps; i++) activateStep(2, i, density);
      fillPercPattern([3, 7, 11, 15]);
      addHatAccentOverlay(accentProb);
      pushSketchVariation(0.5);
      finalizeSketch(`Techno ${technoFlavor ? technoFlavor.value : ""}`.trim(), params, 0.5, genreSketchSummary, genreVariation, genreVariationValue);
    }

    function sketchHipHop() {
      setSketchActive("sketchHipHop");
      resetSequence();
      const params = getSketchParams();
      const density = params.density === "Sparse" ? 0.32 : params.density === "Dense" ? 0.68 : 0.48;
      // Hip hop: syncopated kicks, laid-back hats, ghosted snare.
      const kicks = mutatePattern(pickVariant(HIPHOP_KICKS), 2, [0, 3, 5, 6, 7, 9, 10, 12, 13, 14, 15]);
      const snares = mutatePattern(pickVariant(HIPHOP_SNARES), 1, [4, 12, 15]);
      const ghosts = mutatePattern(pickVariant(HIPHOP_GHOSTS), 2, [2, 3, 6, 7, 9, 10, 14, 15]);
      fillKickPattern(kicks);
      fillSnarePattern(snares);
      fillGhosts(1, ghosts, 0.35);
      fillHatPattern(density);
      fillPercPattern([9, 13]);
      pushSketchVariation(0.45);
      finalizeSketch(`Hip Hop ${hiphopFlavor ? hiphopFlavor.value : ""}`.trim(), params, 0.45, genreSketchSummary, genreVariation, genreVariationValue);
    }

    function pickFromSelect(selectEl, options) {
      if (!selectEl) return pickVariant(options);
      const value = selectEl.value;
      return value === "random" ? pickVariant(options) : value;
    }

    function getSketchParams() {
      return {
        groove: pickFromSelect(sketchGroove, SKETCH_PARAMS.groove),
        density: pickFromSelect(sketchDensity, SKETCH_PARAMS.density),
        accent: pickFromSelect(sketchAccent, SKETCH_PARAMS.accent),
        humanize: pickFromSelect(sketchHumanize, SKETCH_PARAMS.humanize)
      };
    }

    function setVariationIndicator(meterEl, valueEl, amount) {
      if (meterEl) {
        const span = meterEl.querySelector("span");
        if (span) span.style.width = `${Math.round(amount * 100)}%`;
      }
      if (valueEl) valueEl.textContent = `Var ${Math.round(amount * 100)}%`;
    }

    function updateSketchSummary(name, params, targetEl) {
      if (!targetEl) return;
      targetEl.textContent = `${name} • ${params.groove} / ${params.density} / ${params.accent} / ${params.humanize}`;
    }

    function renderPalettePanel() {
      if (!paletteList) return;
      paletteList.innerHTML = "";
      INSTRUMENT_PALETTE.forEach((item) => {
        const row = document.createElement("div");
        row.className = "palette-item";
        row.innerHTML = `<span>${item.name}</span><span class="palette-tag">${item.tag}</span>`;
        paletteList.appendChild(row);
      });
    }

    function generateWhimsicalName() {
      const a = ["Dust", "Wonk", "Rust", "Velvet", "Ghost", "Oil", "Neon", "Spiral", "Liquid", "Hush"];
      const b = ["Spiral", "Crunch", "Bloom", "Stutter", "Flicker", "Collapse", "Echo", "Drift", "Valve", "Pulse"];
      return `${pickVariant(a)} ${pickVariant(b)}`;
    }

    function setRandomSketchSelects() {
      if (sketchGroove) sketchGroove.value = "random";
      if (sketchDensity) sketchDensity.value = "random";
      if (sketchAccent) sketchAccent.value = "random";
      if (sketchHumanize) sketchHumanize.value = "random";
    }

    function surpriseSketch() {
      setRandomSketchSelects();
      const params = getSketchParams();
      const name = generateWhimsicalName();
      const options = [sketchPocket, sketchLurch, sketchShuffle, sketchHouse, sketchTechno, sketchHipHop];
      const fn = pickVariant(options);
      fn();
      updateSketchSummary(name, params, genreSketchSummary);
      lastSketchName = name;
    }

    function applyHumanizeMode(mode) {
      const map = { Mild: 0.2, Live: 0.5, Chaos: 0.9 };
      randomizeHumanizeDials(map[mode] ?? 0.35);
    }

    function finalizeSketch(name, params, variationAmount, summaryEl, variationMeter, variationValueEl) {
      applyHumanizePreset(groovePreset.value);
      applyHumanizeMode(params.humanize);
      applySketchParamNudges();
      if (Math.random() < evolutionAmount) {
        mutateTowardDivergence(1 + evolutionAmount * 2);
      }
      let divergence = getDivergenceScore(makePatternSignature());
      if (divergence < 0.3) {
        mutateTowardDivergence(1.5);
      }
      rollHumanizeForAllSteps();
      refreshStepUI();
      lastSketchName = name;
      divergence = pushEvolutionSnapshot();
      setVariationIndicator(variationMeter, variationValueEl, variationAmount);
      updateSketchSummary(`${name} • Div ${Math.round(divergence * 100)}%`, params, summaryEl);
    }

    function pickVariant(options) {
      return options[Math.floor(Math.random() * options.length)];
    }

    function mutatePattern(stepsList, maxMutations, allowedSteps) {
      const stepsSet = new Set(stepsList);
      const mutations = Math.floor(Math.random() * (maxMutations + 1));
      for (let i = 0; i < mutations; i++) {
        const roll = Math.random();
        if (roll < 0.4 && stepsSet.size > 1) {
          // Drop a hit.
          const existing = Array.from(stepsSet);
          stepsSet.delete(existing[Math.floor(Math.random() * existing.length)]);
        } else if (roll < 0.75) {
          // Shift a hit by ±1 if possible.
          const existing = Array.from(stepsSet);
          const base = existing[Math.floor(Math.random() * existing.length)];
          const shift = Math.random() > 0.5 ? 1 : -1;
          const candidate = (base + shift + steps) % steps;
          if (allowedSteps.includes(candidate)) {
            stepsSet.delete(base);
            stepsSet.add(candidate);
          }
        } else {
          // Add a new hit from allowed pool.
          const candidate = allowedSteps[Math.floor(Math.random() * allowedSteps.length)];
          stepsSet.add(candidate);
        }
      }
      return Array.from(stepsSet).sort((a, b) => a - b);
    }

    function addHatAccentOverlay(probability) {
      // Subtle 5-step accent overlay (still 4/4 core).
      if (Math.random() > probability) return;
      for (let i = 0; i < steps; i += 5) {
        if (Math.random() < 0.7) activateStep(2, i, 0.35);
      }
    }

    function applySketchParamNudges() {
      // Stronger per-sketch param variation to make sounds more distinct.
      trackState.forEach((state, index) => {
        const chaosScale = chaosAmount("tone");
        const pitchNudge = (Math.random() - 0.5) * 5 * chaosScale; // ±2.5 semitones
        const decayNudge = (Math.random() - 0.5) * 0.5 * chaosScale; // ±25%
        const filterNudge = (Math.random() - 0.5) * 0.5 * chaosScale; // ±25%
        const distNudge = (Math.random() - 0.5) * 0.35 * chaosScale;
        const crushNudge = (Math.random() - 0.5) * 0.3 * chaosScale;
        const delayNudge = (Math.random() - 0.5) * 0.3 * chaosScale;
        const reverbNudge = (Math.random() - 0.5) * 0.3 * chaosScale;
        const lfoNudge = (Math.random() - 0.5) * 0.4 * chaosScale;
        const fxNudge = (Math.random() - 0.5) * 0.4 * chaosScale;
        const stretchNudge = (Math.random() - 0.5) * 0.4 * chaosScale;
        const sliceNudge = Math.floor((Math.random() - 0.5) * 6 * chaosScale);

        if (index >= 2) {
          state.pitch = clamp(state.pitch + pitchNudge, -12, 12);
        }
        state.decay = clamp(state.decay + decayNudge, 0.08, 1.2);
        state.filter = clamp(state.filter * (1 + filterNudge), 300, 8000);
        state.dist = clamp(state.dist + distNudge, 0, 1);
        state.crush = clamp(state.crush + crushNudge, 0, 1);
        state.delay = clamp(state.delay + delayNudge, 0, 1);
        state.reverb = clamp(state.reverb + reverbNudge, 0, 1);
        state.lfo = clamp(state.lfo + lfoNudge, 0, 1);
        state.fx = clamp(state.fx + fxNudge, 0, 1);
        state.stretch = clamp(state.stretch + stretchNudge, 0.5, 2);
        state.slice = clamp(state.slice + sliceNudge, 0, 15);

        updateTrackParam(index, "pitch", state.pitch);
        updateTrackParam(index, "decay", state.decay * 100);
        updateTrackParam(index, "filter", state.filter);
        updateTrackParam(index, "dist", state.dist * 100);
        updateTrackParam(index, "crush", state.crush * 100);
        updateTrackParam(index, "delay", state.delay * 100);
        updateTrackParam(index, "reverb", state.reverb * 100);
        updateTrackParam(index, "lfo", state.lfo * 100);
        updateTrackParam(index, "fx", state.fx * 100);
        updateTrackParam(index, "stretch", state.stretch);
        updateTrackParam(index, "slice", state.slice);
        updateKnobVisual(index);
      });
    }

    function pushSketchVariation(amount) {
      const chaosScale = chaosAmount("timing");
      const scaled = amount * chaosScale;
      // Global variation surge that hits groove + sound shaping.
      humanize.looseness = clamp(humanize.looseness + randomInRange(-12, 12) * scaled, 0, 40);
      humanize.velocityVar = clamp(humanize.velocityVar + randomInRange(-0.2, 0.2) * scaled, 0, 0.5);
      humanize.swingVar = clamp(humanize.swingVar + randomInRange(-10, 10) * scaled, 0, 30);
      humanize.pulseDrift = clamp(humanize.pulseDrift + randomInRange(-0.6, 0.6) * scaled, 0, 2);
      humanize.detune = clamp(humanize.detune + randomInRange(-0.8, 0.8) * scaled, 0, 2);
      humanize.mod = clamp(humanize.mod + randomInRange(-0.2, 0.2) * scaled, 0, 0.5);
      updateHumanizeUI();

      trackState.forEach((state, index) => {
        const toneChaos = chaosAmount("tone");
        const extraFilter = 1 + randomInRange(-0.35, 0.35) * amount * toneChaos;
        const extraDecay = randomInRange(-0.35, 0.35) * amount * toneChaos;
        state.filter = clamp(state.filter * extraFilter, 300, 8000);
        state.decay = clamp(state.decay + extraDecay, 0.08, 1.2);
        state.dist = clamp(state.dist + randomInRange(-0.35, 0.35) * amount * toneChaos, 0, 1);
        state.crush = clamp(state.crush + randomInRange(-0.35, 0.35) * amount * toneChaos, 0, 1);
        state.lfo = clamp(state.lfo + randomInRange(-0.4, 0.4) * amount * toneChaos, 0, 1);
        updateTrackParam(index, "filter", state.filter);
        updateTrackParam(index, "decay", state.decay * 100);
        updateTrackParam(index, "dist", state.dist * 100);
        updateTrackParam(index, "crush", state.crush * 100);
        updateTrackParam(index, "lfo", state.lfo * 100);
      });
    }

    function setSketchActive(activeId) {
      const ids = ["sketchA", "sketchB", "sketchC", "sketchHouse", "sketchTechno", "sketchHipHop"];
      ids.forEach((id) => {
        const el = document.getElementById(id);
        if (!el) return;
        el.classList.toggle("active", id === activeId);
      });
    }

    function updateKnobVisual(trackIndex) {
      const pitchVal = trackState[trackIndex].pitch;
      const filterVal = trackState[trackIndex].filter;
      const decayVal = trackState[trackIndex].decay;
      const pitchAngle = mapRange(pitchVal, -12, 12, -135, 135);
      const filterAngle = mapRange(filterVal, 300, 8000, -135, 135);
      const decayAngle = mapRange(decayVal, 0.1, 1.2, -135, 135);
      const pitchVis = document.getElementById(`knobPitchVis-${trackIndex}`);
      const filterVis = document.getElementById(`knobFilterVis-${trackIndex}`);
      const decayVis = document.getElementById(`knobDecayVis-${trackIndex}`);
      if (pitchVis) pitchVis.style.setProperty("--angle", `${pitchAngle}deg`);
      if (filterVis) filterVis.style.setProperty("--angle", `${filterAngle}deg`);
      if (decayVis) decayVis.style.setProperty("--angle", `${decayAngle}deg`);
    }

    function mapRange(value, inMin, inMax, outMin, outMax) {
      const clamped = clamp(value, inMin, inMax);
      return outMin + ((clamped - inMin) / (inMax - inMin)) * (outMax - outMin);
    }

    function randomizeHumanizeDials(amount) {
      const chaosScale = chaosAmount("timing");
      const scaled = amount * chaosScale;
      humanize.looseness = clamp(humanize.looseness + randomInRange(-8, 8) * scaled, 0, 40);
      humanize.velocityVar = clamp(humanize.velocityVar + randomInRange(-0.1, 0.1) * scaled, 0, 0.4);
      humanize.swingVar = clamp(humanize.swingVar + randomInRange(-6, 6) * scaled, 0, 30);
      humanize.pulseDrift = clamp(humanize.pulseDrift + randomInRange(-0.4, 0.4) * scaled, 0, 2);
      humanize.detune = clamp(humanize.detune + randomInRange(-0.4, 0.4) * scaled, 0, 2);
      humanize.mod = clamp(humanize.mod + randomInRange(-0.1, 0.1) * scaled, 0, 0.4);
      updateHumanizeUI();
    }

    function refreshStepUI() {
      sequence.forEach((row, rowIndex) => {
        row.forEach((step, stepIndex) => {
          const el = document.querySelector(`.step[data-track="${rowIndex}"][data-step="${stepIndex}"]`);
          el.classList.toggle("on", step.on);
          el.dataset.vel = step.on ? step.velocity.toFixed(2) : "";
          applyStepVisuals(step, el);
        });
      });
    }

    function fillKickPattern(stepsList) {
      stepsList.forEach((s) => activateStep(0, s, 0.85));
    }

    function fillSnarePattern(stepsList) {
      stepsList.forEach((s) => activateStep(1, s, 0.65));
    }

    function fillHatPattern(density) {
      for (let i = 0; i < steps; i++) {
        if (Math.random() < density) activateStep(2, i, 0.45 + Math.random() * 0.3);
      }
    }

    function fillRidePattern(stepsList) {
      stepsList.forEach((s) => activateStep(6, s, 0.35));
    }

    function fillPercPattern(stepsList) {
      stepsList.forEach((s) => activateStep(5, s, 0.4));
    }

    function fillGhosts(trackIndex, stepsList, velocity) {
      stepsList.forEach((s) => activateStep(trackIndex, s, velocity));
    }

    function activateStep(trackIndex, stepIndex, velocity, force = false) {
      if (!force && sketchLocks.has(trackIndex)) return;
      const step = sequence[trackIndex][stepIndex];
      step.on = true;
      step.velocity = velocity;
      step.offset = microOffsets[Math.floor(Math.random() * microOffsets.length)];
      rollHumanizeForStep(step);
    }

    function randomInRange(min, max) {
      return min + Math.random() * (max - min);
    }

    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function clamp01(x) { return Math.max(0, Math.min(1, x)); }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function centsToRate(cents) { return Math.pow(2, cents / 1200); }

    function pressureCurve(p) {
      // safe zone until ~0.6, then ramps
      if (p < 0.6) return 0.70 * p;
      const t = (p - 0.6) / 0.4; // 0..1
      return 0.42 + 0.58 * Math.pow(t, 1.8);
    }

    function getChaosNormalized() {
      const chaosEl = document.getElementById("chaos");
      if (!chaosEl) return 0;
      return clamp(Number(chaosEl.value) / 200, 0, 1);
    }

    function getChaosTier() {
      const c = getChaosNormalized();
      if (c < 0.3) return 0;
      if (c < 0.6) return 1;
      if (c < 0.8) return 2;
      return 3;
    }

    function chaosAmount(kind) {
      const base = getChaosScale();
      const tier = getChaosTier();
      if (kind === "timing") return base;
      if (kind === "tone") return tier >= 1 ? base : 0;
      if (kind === "density") return tier >= 2 ? base : 0;
      if (kind === "probability") return tier >= 3 ? base : 0;
      return 0;
    }

    function couplingMultiplier(mode) {
      switch (mode) {
        case "punch": return 1.10;
        case "dirt": return 1.15;
        case "collapse": return 1.25;
        case "glue":
        default: return 1.00;
      }
    }

    function updateStressHeat() {
      // ---- INPUTS ----
      const E = clamp01(behavior.energy);
      const D = clamp01(behavior.density);
      const I = clamp01(behavior.impulse);

      const P_eff = pressureCurve(clamp01(behavior.pressure));
      const K_mode = couplingMultiplier(headroomModeValue);

      // ---- BASE LOAD (0..1) ----
      // Energy dominates, density and impulse add perceived circuit load.
      let L = 0.45 * E + 0.30 * D + 0.15 * I;
      L = clamp01(L);

      // ---- PRESSURE AMPLIFIES LOAD (identity move) ----
      const PRESSURE_GAIN = 1.2;           // 0..~2.2x load
      const Amp = 1 + PRESSURE_GAIN * P_eff;

      let L_pushed = clamp01(L * Amp * K_mode);

      // ---- STRESS TARGET ----
      const S_target = Math.pow(L_pushed, 1.15);

      // Asymmetric smoothing: fast rise, slow fall (hardware feel)
      const alphaUp = 0.18;
      const alphaDown = 0.06;
      behavior.stress = (S_target > behavior.stress)
        ? lerp(behavior.stress, S_target, alphaUp)
        : lerp(behavior.stress, S_target, alphaDown);

      behavior.stress = clamp01(behavior.stress);

      // ---- HEAT (slow temperature) ----
      const HEAT_FLOOR = 0.20;
      const H_input = clamp01((behavior.stress - HEAT_FLOOR) / (1 - HEAT_FLOOR));

      // Per-step update assumptions: ~8 steps/sec at 120bpm (16ths).
      // These rates give "minutes-long" thermal behavior.
      const heatRise = 0.012;
      const heatDecay = 0.002;

      behavior.heat = behavior.heat + heatRise * (H_input - behavior.heat);
      behavior.heat = behavior.heat - heatDecay * behavior.heat;
      behavior.heat = clamp01(behavior.heat);

      // ---- DERIVED OUTPUTS (0..1 or small offsets) ----
      const S = behavior.stress;
      const H = behavior.heat;

      behavior.timingTighten = clamp01(Math.pow(S, 1.6));

      behavior.envScale = 1 + 0.35 * S + 0.25 * H;
      behavior.driveScale = 1 + 0.45 * Math.pow(S, 1.4) + 0.20 * H;

      // noise is more "heat" than "stress" (temperature rises noise floor)
      behavior.noiseBoost = 0.006 + 0.020 * Math.pow(H, 1.7) + 0.008 * S;

      // Optional outputs for later wiring (voltage sag, cutoff droop, damping)
      const sagAmount = 0.35; // if you add a UI knob later, replace this const
      behavior.sagCents = -Math.min(12, (2 + 8 * H + 4 * S) * sagAmount);
      behavior.cutoffDroopHz = -(30 * S + 120 * H) * sagAmount;
      behavior.hfDampBoost = 0.05 * S + 0.10 * H;
    }

    function mapLog01(x, minHz, maxHz) {
      const minLog = Math.log(minHz);
      const maxLog = Math.log(maxHz);
      return Math.exp(minLog + (maxLog - minLog) * x);
    }

    function applyHfDamping(q, cutoffHz) {
      const dynamicStartQ = Math.max(0.5, hfDampStartQ - behavior.hfDampBoost * 2.2);
      const dynamicAmount = clamp(hfDampAmount + behavior.hfDampBoost, 0, 0.42);
      if (q <= dynamicStartQ) {
        return { cutoff: cutoffHz, q1: q, q2: q * 0.85 };
      }
      const excess = q - dynamicStartQ;
      const t = Math.min(1, excess / 10);
      const dampFactor = 1 - dynamicAmount * t;
      const q1 = q;
      const q2 = q * (0.85 - 0.12 * t);
      return {
        cutoff: Math.max(40, cutoffHz * dampFactor),
        q1: Math.max(0.1, q1),
        q2: Math.max(0.1, q2)
      };
    }

    function triggerCharacterEnvelope(time, accent = 1.0) {
      if (!characterEnabled || !characterFilter1 || !characterFilter2) return;

      const energyHz = energyModEnabled ? (energyValue * energyModDepthHz) : 0;
      const driftHz = longDrift * 80;
      const droopHz = (30 * behavior.stress + 120 * behavior.heat);
      const base = Math.max(80, characterBaseCutoff + energyHz + driftHz - droopHz);

      const rand = 1 + (Math.random() * 2 - 1) * characterJitterAmount;
      lastJitter = lastJitter * 0.7 + rand * 0.3;
      const jitteredBase = base * lastJitter;

      const envDepth = characterEnvAmount * accent * behavior.envScale;
      const rawPeak = jitteredBase + envDepth;

      const qBoost = 0.18 * accent;
      const targetQ = characterBaseQ + qBoost;

      const dampedBase = applyHfDamping(targetQ, jitteredBase);
      const dampedPeak = applyHfDamping(targetQ, rawPeak);

      const f1 = characterFilter1.frequency;
      const f2 = characterFilter2.frequency;
      const q1 = characterFilter1.Q;
      const q2 = characterFilter2.Q;

      f1.cancelScheduledValues(time);
      f2.cancelScheduledValues(time);
      f1.setValueAtTime(dampedBase.cutoff, time);
      f2.setValueAtTime(dampedBase.cutoff, time);

      const stage2Peak = dampedPeak.cutoff * 0.96;
      f1.linearRampToValueAtTime(dampedPeak.cutoff, time + characterEnvAttack);
      f2.linearRampToValueAtTime(stage2Peak, time + characterEnvAttack);
      const endTime = time + characterEnvAttack + characterEnvDecay;
      f1.exponentialRampToValueAtTime(Math.max(40, dampedBase.cutoff), endTime);
      f2.exponentialRampToValueAtTime(Math.max(40, dampedBase.cutoff), endTime);

      q1.cancelScheduledValues(time);
      q2.cancelScheduledValues(time);
      q1.setValueAtTime(dampedBase.q1, time);
      q2.setValueAtTime(dampedBase.q2, time);
      q1.linearRampToValueAtTime(dampedPeak.q1, time + characterEnvAttack);
      q2.linearRampToValueAtTime(dampedPeak.q2, time + characterEnvAttack);
      q1.exponentialRampToValueAtTime(Math.max(0.1, dampedBase.q1), endTime);
      q2.exponentialRampToValueAtTime(Math.max(0.1, dampedBase.q2), endTime);

      if (characterPreGain) {
        const g = characterPreGain.gain;
        const stage1Drive = 1 + 0.4 * behavior.stress;
        const stage2Drive = 1 + 0.7 * behavior.stress;
        const drivePeak = (characterBaseDrive + characterDriveEnvAmount * accent * behavior.driveScale) * stage1Drive;
        g.cancelScheduledValues(time);
        g.setValueAtTime(characterBaseDrive, time);
        g.linearRampToValueAtTime(drivePeak, time + 0.003);
        g.exponentialRampToValueAtTime(Math.max(0.001, characterBaseDrive), time + characterDriveEnvDecay);
        if (characterPostGain) {
          const post = characterPostGain.gain;
          const postPeak = clamp(1 + 0.12 * (stage2Drive - 1), 1, 1.35);
          post.cancelScheduledValues(time);
          post.setValueAtTime(1, time);
          post.linearRampToValueAtTime(postPeak, time + 0.004);
          post.exponentialRampToValueAtTime(1, time + characterDriveEnvDecay);
        }
      }
    }

    function startEnergyMeter() {
      if (energyTimerId) return;
      const intervalMs = Math.max(10, Math.floor(1000 / energyUpdateHz));
      energyTimerId = setInterval(() => {
        if (!energyModEnabled || !energyAnalyser) return;
        energyAnalyser.getFloatTimeDomainData(energyData);
        let sum = 0;
        for (let i = 0; i < energyData.length; i++) {
          const v = energyData[i];
          sum += v * v;
        }
        const rms = Math.sqrt(sum / energyData.length);
        const target = Math.min(1, rms * 6.0);
        energyValue = energyValue * energyModSmooth + target * (1 - energyModSmooth);
      }, intervalMs);
    }

    function stopEnergyMeter() {
      if (energyTimerId) {
        clearInterval(energyTimerId);
        energyTimerId = null;
      }
    }

    function getChaosScale() {
      const chaosEl = document.getElementById("chaos");
      if (!chaosEl) return 1;
      return clamp(Number(chaosEl.value) / 100, 0, 2);
    }

    function getModMatrixDeltas(hitCount, maxAccent) {
      const densityNorm = clamp(hitCount / Math.max(1, tracks.length), 0, 1);
      const swingNorm = clamp(Number(swing.value) / 70, 0, 1);
      const chaosNorm = clamp(chaosAmount("tone") / 2, 0, 1);
      const energyNorm = clamp(energyValue, 0, 1);
      return {
        densityToCutoff: densityNorm * 160,
        swingToRes: swingNorm * 0.6,
        chaosToCrush: chaosNorm * 0.25,
        energyToNoise: energyNorm * 0.18,
        accentToDrive: clamp(maxAccent, 0, 1.4) * 0.12
      };
    }

    function getHeadroomStepProfile(hits) {
      if (!hits.length || headroomModeValue === "off") {
        transientAccentBoost = 0;
        previousStepLoad *= 0.9;
        kickTransientBoost = 1;
        preSaturationDrive = 1;
        if (masterCompressor) {
          masterCompressor.release.value = 0.16;
          masterCompressor.threshold.value = -22;
        }
        return { globalGain: 1, hatDuck: 0, snareAccent: 0, postLoad: previousStepLoad, kickTransientBoost: 1, preSaturationDrive: 1 };
      }
      const stepLoad = clamp(hits.reduce((sum, h) => sum + h.velocity, 0) / 5.5, 0, 1.6);
      const kickEnergy = hits.filter((h) => h.track.tone === "kick").reduce((sum, h) => sum + h.velocity, 0);
      const snareEnergy = hits.filter((h) => h.track.tone === "snare").reduce((sum, h) => sum + h.velocity, 0);
      const ratio = headroomAmountValueNum;
      const stress = behavior.stress;
      let globalGain = 1;
      let hatDuck = 0;
      let snareAccent = 0;
      let kickBoost = 1;
      let saturationDrive = 1;
      if (headroomModeValue === "glue") {
        globalGain = 1 - stepLoad * 0.1 * ratio;
        if (masterCompressor) {
          masterCompressor.release.value = clamp(0.2 + 0.25 * stress, 0.05, 0.9);
          masterCompressor.threshold.value = -22;
        }
      } else if (headroomModeValue === "punch") {
        hatDuck = clamp(kickEnergy * 0.28 * ratio, 0, 0.45);
        snareAccent = clamp(snareEnergy * 0.18 * ratio, 0, 0.22);
        kickBoost = 1 + 0.25 * stress;
        if (masterCompressor) {
          masterCompressor.release.value = 0.16;
          masterCompressor.threshold.value = -22;
        }
      } else if (headroomModeValue === "dirt") {
        globalGain = 1 - stepLoad * 0.18 * ratio;
        snareAccent = clamp(stepLoad * 0.15 * ratio, 0, 0.2);
        saturationDrive = 1 + 0.4 * stress;
        if (masterCompressor) {
          masterCompressor.release.value = 0.18;
          masterCompressor.threshold.value = -22;
        }
      } else if (headroomModeValue === "collapse") {
        const collapse = clamp((stepLoad + previousStepLoad * 0.75) * 0.2 * ratio, 0, 0.35);
        globalGain = 1 - collapse;
        hatDuck = collapse * 0.7;
        if (masterCompressor) {
          masterCompressor.release.value = 0.22;
          masterCompressor.threshold.value = clamp(-18 - (6 * stress), -30, -18);
        }
      }
      kickTransientBoost = kickBoost;
      preSaturationDrive = saturationDrive;
      transientAccentBoost = snareAccent;
      const postLoad = clamp(previousStepLoad * 0.8 + stepLoad * 0.2, 0, 1.8);
      previousStepLoad = postLoad;
      return { globalGain, hatDuck, snareAccent, postLoad, kickTransientBoost: kickBoost, preSaturationDrive: saturationDrive };
    }

    function applyHeadroomToVelocity(hit, velocity, profile) {
      let out = velocity * profile.globalGain;
      if (hit.track.tone === "kick") out *= profile.kickTransientBoost || 1;
      if (hit.track.tone === "hat" || hit.track.tone === "ride") out *= 1 - profile.hatDuck;
      if (hit.track.tone === "snare") out *= 1 + profile.snareAccent;
      if (headroomModeValue === "collapse" && hit.track.tone === "tom") {
        out *= clamp(1 - profile.postLoad * 0.12, 0.65, 1);
      }
      return clamp(out, 0.02, 1.1);
    }

    function computeVelocityCrush(baseCrush, velocity, chaosDelta) {
      if (velocityCrushModeValue === "off") return clamp(baseCrush + chaosDelta, 0, 1);
      const velNorm = clamp(velocity / 1.2, 0, 1);
      const bias = velocityCrushModeValue === "accent_grit" ? velNorm : (1 - velNorm);
      const dynamic = bias * (0.28 + behavior.stress * 0.18);
      return clamp(baseCrush + dynamic + chaosDelta, 0, 1);
    }

    function makePatternSignature() {
      const packed = [];
      for (let t = 0; t < sequence.length; t++) {
        for (let s = 0; s < steps; s++) {
          const step = sequence[t][s];
          if (!step.on) {
            packed.push("0");
            continue;
          }
          const velBucket = Math.round(clamp(step.velocity, 0, 1.2) * 9);
          packed.push(`1${velBucket.toString(36)}`);
        }
      }
      return packed.join("");
    }

    function getDivergenceScore(signature) {
      if (!evolutionMemory.length) return 1;
      let bestSimilarity = 0;
      for (let i = 0; i < evolutionMemory.length; i++) {
        const prev = evolutionMemory[i];
        let same = 0;
        const len = Math.min(signature.length, prev.length);
        for (let j = 0; j < len; j++) {
          if (signature[j] === prev[j]) same += 1;
        }
        const similarity = len ? same / len : 0;
        if (similarity > bestSimilarity) bestSimilarity = similarity;
      }
      return clamp(1 - bestSimilarity, 0, 1);
    }

    function mutateTowardDivergence(intensity = 1) {
      const mutationCount = Math.max(1, Math.round((2 + behavior.stress * 4) * intensity));
      for (let i = 0; i < mutationCount; i++) {
        const t = Math.floor(Math.random() * tracks.length);
        if (sketchLocks.has(t)) continue;
        const s = Math.floor(Math.random() * steps);
        const step = sequence[t][s];
        if (Math.random() < 0.5) {
          step.on = !step.on;
        }
        if (step.on) {
          step.velocity = clamp(step.velocity + randomInRange(-0.18, 0.18), 0.2, 1.1);
          step.offset = microOffsets[Math.floor(Math.random() * microOffsets.length)];
        }
      }
    }

    function getEvolutionProfile() {
      const name = (lastSketchName || "").toLowerCase();
      const houseActive = document.getElementById("sketchHouse")?.classList.contains("active");
      const technoActive = document.getElementById("sketchTechno")?.classList.contains("active");
      const hiphopActive = document.getElementById("sketchHipHop")?.classList.contains("active");
      if (hiphopActive || name.includes("hip hop") || name.includes("hiphop")) {
        return {
          coreTracks: [0, 1],
          supportTracks: [2, 3, 4, 5, 6, 7],
          anchors: { 0: [0, 7, 10, 13], 1: [4, 12] },
          allowed: {
            0: [0, 2, 5, 6, 7, 9, 10, 12, 13, 14, 15],
            1: [4, 12, 15],
            2: ALL_STEPS,
            3: [4, 12, 15],
            4: [3, 7, 11, 15],
            5: [2, 6, 10, 14],
            6: [0, 4, 8, 12],
            7: [3, 6, 9, 14]
          }
        };
      }
      if (technoActive || name.includes("techno")) {
        return {
          coreTracks: [0, 1],
          supportTracks: [2, 3, 4, 5, 6, 7],
          anchors: { 0: [0, 4, 8, 12], 1: [4, 12] },
          allowed: {
            0: [0, 2, 4, 6, 8, 10, 12, 14, 15],
            1: [4, 12, 15],
            2: ALL_STEPS,
            3: [4, 12],
            4: [3, 7, 11, 15],
            5: [1, 5, 9, 13],
            6: [0, 4, 8, 12],
            7: [2, 6, 10, 14]
          }
        };
      }
      if (houseActive || name.includes("house")) {
        return {
          coreTracks: [0, 1],
          supportTracks: [2, 3, 4, 5, 6, 7],
          anchors: { 0: [0, 4, 8, 12], 1: [4, 12] },
          allowed: {
            0: [0, 4, 8, 12, 15],
            1: [4, 12, 14],
            2: ALL_STEPS,
            3: [4, 12],
            4: [3, 7, 11, 15],
            5: [2, 6, 10, 14],
            6: [0, 4, 8, 12],
            7: [7, 11, 15]
          }
        };
      }
      return {
        coreTracks: [0, 1],
        supportTracks: [2, 3, 4, 5, 6, 7],
        anchors: { 0: [0, 8], 1: [4, 12] },
        allowed: {
          0: [0, 2, 4, 6, 8, 10, 12, 14],
          1: [4, 12, 15],
          2: ALL_STEPS,
          3: [4, 12],
          4: [3, 7, 11, 15],
          5: [2, 6, 10, 14],
          6: [0, 4, 8, 12],
          7: [3, 7, 11, 15]
        }
      };
    }

    function isAnchorStep(profile, trackIndex, stepIndex) {
      const anchors = profile.anchors?.[trackIndex] || [];
      return anchors.includes(stepIndex);
    }

    function getMinActiveSteps(trackIndex) {
      if (trackIndex === 0) return 2;
      if (trackIndex === 1) return 1;
      if (trackIndex === 2) return 2;
      return 0;
    }

    function isDownbeat(stepIndex) {
      return stepIndex % 4 === 0;
    }

    function createGhostNote(row, stepIndex) {
      if (!row[stepIndex] || row[stepIndex].on) return false;
      row[stepIndex].on = true;
      row[stepIndex].velocity = clamp(0.24 + randomInRange(-0.06, 0.08), 0.15, 0.45);
      row[stepIndex].offset = microOffsets[Math.floor(Math.random() * microOffsets.length)];
      rollHumanizeForStep(row[stepIndex]);
      return true;
    }

    function mutateOneEvolutionStep(profile, evolveAmount) {
      const coreChance = 0.08 + evolveAmount * 0.18;
      const pool = Math.random() < coreChance
        ? [...profile.coreTracks, ...profile.supportTracks]
        : [...profile.supportTracks];
      const candidates = pool.filter((idx) => !sketchLocks.has(idx));
      if (!candidates.length) return false;
      const trackIndex = pickVariant(candidates);
      const row = sequence[trackIndex];
      const allowed = profile.allowed?.[trackIndex] || ALL_STEPS;
      const active = [];
      const inactive = [];
      for (let s = 0; s < steps; s++) {
        if (!allowed.includes(s)) continue;
        if (row[s].on) active.push(s);
        else inactive.push(s);
      }
      if (!active.length && !inactive.length) return false;

      const op = Math.random();
      const velocityOnly = behavior.density > 0.6;

      // Most mutations are continuity-safe changes to existing hits.
      if (op < 0.5 && active.length) {
        const safeActive = active.filter((s) => !isDownbeat(s));
        if (!safeActive.length) return false;
        const s = pickVariant(safeActive);
        const step = row[s];
        const jitter = 0.05 + evolveAmount * 0.1;
        step.velocity = clamp(step.velocity + randomInRange(-jitter, jitter), 0.25, 1.05);
        if (!velocityOnly && Math.random() < 0.35) {
          const idx = microOffsets.indexOf(step.offset);
          const delta = Math.random() < 0.5 ? -1 : 1;
          const next = clamp(idx + delta, 0, microOffsets.length - 1);
          step.offset = microOffsets[next];
        }
        rollHumanizeForStep(step);
        return true;
      }

      if (!velocityOnly && op < 0.72 && active.length) {
        const movable = active.filter((s) => !isDownbeat(s));
        if (!movable.length) return false;
        const from = pickVariant(movable);
        const shift = Math.random() < 0.5 ? -1 : 1;
        const to = (from + shift + steps) % steps;
        if (isDownbeat(to) || !allowed.includes(to) || row[to].on) return false;
        if (isAnchorStep(profile, trackIndex, from) && !isAnchorStep(profile, trackIndex, to)) return false;
        row[to] = { ...row[from] };
        row[from] = { ...row[from], on: false };
        return true;
      }

      if (!velocityOnly && op < 0.86 && active.length) {
        const removable = active.filter((s) => !isDownbeat(s));
        if (!removable.length) return false;
        const from = pickVariant(removable);
        if (isAnchorStep(profile, trackIndex, from)) return false;
        if (active.length <= getMinActiveSteps(trackIndex)) return false;
        row[from].on = false;
        row[from].offset = 0;
        return true;
      }

      if (!inactive.length) return false;
      const insertable = inactive.filter((s) => !isDownbeat(s));
      if (!insertable.length) return false;
      const to = pickVariant(insertable);
      if (Math.random() < 0.6) {
        return createGhostNote(row, to);
      }
      const baseVel = trackIndex === 0 ? 0.78 : trackIndex === 1 ? 0.62 : 0.42;
      row[to].on = true;
      row[to].velocity = clamp(baseVel + randomInRange(-0.14, 0.14), 0.2, 1.05);
      row[to].offset = microOffsets[Math.floor(Math.random() * microOffsets.length)];
      rollHumanizeForStep(row[to]);
      return true;
    }

    function evolveCurrentBar() {
      if (!isPlaying) return;
      if (evolutionAmount <= 0) return;

      const mutationChance = 0.03 + (0.04 * evolutionAmount);
      if (Math.random() > mutationChance) return;

      const profile = getEvolutionProfile();
      const mutationBudget = 1 + Math.floor(evolutionAmount * 3);
      let applied = 0;
      for (let i = 0; i < mutationBudget; i++) {
        if (mutateOneEvolutionStep(profile, evolutionAmount)) applied += 1;
      }
      if (!applied) return;

      rollHumanizeForAllSteps();
      refreshStepUI();
      pushEvolutionSnapshot();
    }

    function pushEvolutionSnapshot() {
      const signature = makePatternSignature();
      const divergence = getDivergenceScore(signature);
      evolutionMemory.push(signature);
      if (evolutionMemory.length > evolutionMemoryLimit) evolutionMemory.shift();
      if (evolutionMemoryInfo) {
        evolutionMemoryInfo.textContent = `Memory ${evolutionMemory.length}/${evolutionMemoryLimit} · Div ${Math.round(divergence * 100)}%`;
      }
      return divergence;
    }

    const uiState = { mode: "edit", tab: "track" };

    function setupGeneratorSections() {
      const toggleGenreSketch = document.getElementById("toggleGenreSketch");
      const genreSketchBody = document.getElementById("genreSketchBody");
      const genreToggleLabel = document.getElementById("genreToggleLabel");
      const togglePalette = document.getElementById("togglePalette");
      const paletteBody = document.getElementById("paletteBody");
      const paletteToggleLabel = document.getElementById("paletteToggleLabel");

      if (toggleGenreSketch && genreSketchBody) {
        toggleGenreSketch.addEventListener("click", () => {
          const expanded = toggleGenreSketch.getAttribute("aria-expanded") === "true";
          toggleGenreSketch.setAttribute("aria-expanded", String(!expanded));
          genreSketchBody.classList.toggle("collapsed", expanded);
          if (genreToggleLabel) genreToggleLabel.textContent = expanded ? "Collapsed" : "Expanded";
        });
      }

      if (togglePalette && paletteBody) {
        togglePalette.addEventListener("click", () => {
          const expanded = togglePalette.getAttribute("aria-expanded") === "true";
          togglePalette.setAttribute("aria-expanded", String(!expanded));
          paletteBody.classList.toggle("collapsed", expanded);
          if (paletteToggleLabel) paletteToggleLabel.textContent = expanded ? "Collapsed" : "Expanded";
        });
      }
    }

    function setupLayoutSystem() {
      const rightCol = document.querySelector(".right-col");
      const trackDock = document.getElementById("trackControls");
      const knobsCard = document.getElementById("knobsCard");
      const bottomControls = document.querySelector(".bottom-controls");
      if (!rightCol) return;

      const contextPanel = document.createElement("div");
      contextPanel.className = "context-panel";
      contextPanel.innerHTML = `
        <div class="context-tabs">
          <button class="tab-btn active" data-tab="track">TRACK</button>
          <button class="tab-btn" data-tab="groove">GROOVE</button>
          <button class="tab-btn" data-tab="generator">GENERATOR</button>
          <button class="tab-btn" data-tab="tensor">TENSOR</button>
          <button class="tab-btn" data-tab="mix">MIX</button>
        </div>
        <div class="context-body">
          <section class="tab-panel active" data-panel="track"></section>
          <section class="tab-panel" data-panel="groove"></section>
          <section class="tab-panel" data-panel="generator"></section>
          <section class="tab-panel" data-panel="tensor"></section>
          <section class="tab-panel" data-panel="mix"></section>
        </div>
      `;

      // Insert panel shell first, then move existing cards into tab panels.
      // Do not clear rightCol up front or we destroy nodes required by listeners.
      rightCol.prepend(contextPanel);

      const trackPanel = contextPanel.querySelector('[data-panel="track"]');
      const groovePanel = contextPanel.querySelector('[data-panel="groove"]');
      const generatorPanel = contextPanel.querySelector('[data-panel="generator"]');
      const tensorPanel = contextPanel.querySelector('[data-panel="tensor"]');
      const mixPanel = contextPanel.querySelector('[data-panel="mix"]');

      const moveTo = (id, panel) => {
        const node = document.getElementById(id);
        if (node && panel) panel.appendChild(node);
      };
      const addPanelLabel = (panel, text) => {
        if (!panel) return;
        const el = document.createElement("div");
        el.className = "group-label";
        el.textContent = text;
        panel.appendChild(el);
      };

      moveTo("stepEditorCard", trackPanel);
      addPanelLabel(trackPanel, "Body / Tone / Mind");
      moveTo("behaviorCard", trackPanel);

      addPanelLabel(groovePanel, "Body");
      moveTo("pressureCard", groovePanel);
      moveTo("swingCard", groovePanel);
      moveTo("xyCard", groovePanel);
      moveTo("humanizeCard", groovePanel);
      addPanelLabel(groovePanel, "Mind");
      moveTo("chaosCard", groovePanel);
      addPanelLabel(groovePanel, "Tone");
      moveTo("tapeCard", groovePanel);
      moveTo("noiseCard", groovePanel);

      moveTo("quickSketchCard", generatorPanel);
      moveTo("genreSketchCard", generatorPanel);

      moveTo("tensorCard", tensorPanel);
      moveTo("fadersCard", mixPanel);

      if (trackDock && knobsCard) {
        trackDock.appendChild(knobsCard);
      }
      // Remove any leftover direct children except the context panel shell.
      Array.from(rightCol.children).forEach((child) => {
        if (child !== contextPanel) child.remove();
      });
      if (bottomControls && !bottomControls.children.length) {
        bottomControls.style.display = "none";
      }
      setupGeneratorSections();
    }

    function setTab(tabName) {
      const generatorBtn = document.querySelector('.tab-btn[data-tab="generator"]');
      if (tabName === "generator" && generatorBtn && generatorBtn.style.display === "none") {
        tabName = "track";
      }
      uiState.tab = tabName;
      document.querySelectorAll(".tab-btn").forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.tab === tabName);
      });
      document.querySelectorAll(".tab-panel").forEach((panel) => {
        panel.classList.toggle("active", panel.dataset.panel === tabName);
      });
    }

    function setMode(mode) {
      uiState.mode = mode;
      document.body.classList.remove("mode-sketch", "mode-edit", "mode-perform");
      document.body.classList.add(`mode-${mode}`);
      document.querySelectorAll("[data-mode]").forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.mode === mode);
      });
      const generatorBtn = document.querySelector('.tab-btn[data-tab="generator"]');
      if (mode === "perform") {
        if (generatorBtn) generatorBtn.style.display = "none";
        if (uiState.tab === "generator") setTab("track");
        setTab("mix");
        return;
      }
      if (generatorBtn) generatorBtn.style.display = "";
      if (mode === "sketch") setTab("generator");
      if (mode === "edit") setTab("track");
    }

    buildGrid();
    buildTrackControls();
    buildFaders();
    buildKnobs();
    setupLayoutSystem();
    rollHumanizeForAllSteps();

    trackControls.addEventListener("input", (event) => {
      if (event.target.matches("input[type=\"range\"][data-track]")) {
        const trackIndex = Number(event.target.dataset.track);
        const param = event.target.dataset.param;
        updateTrackParam(trackIndex, param, event.target.value);
      }
    });

    faders.addEventListener("input", (event) => {
      if (event.target.matches("input[data-track]")) {
        const trackIndex = Number(event.target.dataset.track);
        updateTrackParam(trackIndex, "volume", event.target.value);
      }
    });

    knobs.addEventListener("input", (event) => {
      if (event.target.matches("input[data-track]")) {
        const trackIndex = Number(event.target.dataset.track);
        const param = event.target.dataset.param;
        updateTrackParam(trackIndex, param, event.target.value);
        updateKnobVisual(trackIndex);
      }
    });

    trackControls.addEventListener("change", (event) => {
      if (event.target.matches("select[data-track]")) {
        const trackIndex = Number(event.target.dataset.track);
        const param = event.target.dataset.param;
        updateTrackParam(trackIndex, param, event.target.value);
        if (event.target.value === "live") {
          initLiveInput();
        }
      }
      if (event.target.matches("input[type=\"file\"][data-track]")) {
        const trackIndex = Number(event.target.dataset.track);
        const file = event.target.files[0];
        if (file) loadSample(trackIndex, file);
      }
    });

    trackControls.addEventListener("click", (event) => {
      if (event.target.matches("button[data-param=\"resample\"]")) {
        const trackIndex = Number(event.target.dataset.track);
        resampleTrack(trackIndex);
      }
    });

    let audioContext;
    let masterGain;
    let masterCompressor;
    let masterSaturation;
    let masterLimiter;
    let reverbImpulse;
    let isPlaying = false;
    let currentStep = 0;
    let schedulerId;
    let nextNoteTime = 0;
    let swingDriftState = 0;
    let pulseDriftState = 0;
    let selectedTrackIndex = 0;
    let selectedStep = null;
    let recorderNode;
    let recorderMonitor;
    let isRecording = false;
    let recordBuffersL = [];
    let recordBuffersR = [];
    let recordLength = 0;
    let isResamplingMaster = false;

    const tempo = document.getElementById("tempo");
    const tempoValue = document.getElementById("tempoValue");
    const swing = document.getElementById("swing");
    const swingValue = document.getElementById("swingValue");
    const tape = document.getElementById("tape");
    const tapeValue = document.getElementById("tapeValue");
    const layer = document.getElementById("layer");
    const layerValue = document.getElementById("layerValue");
    const groovePreset = document.getElementById("groovePreset");
    const looseness = document.getElementById("looseness");
    const loosenessValue = document.getElementById("loosenessValue");
    const velVar = document.getElementById("velVar");
    const velVarValue = document.getElementById("velVarValue");
    const swingVar = document.getElementById("swingVar");
    const swingVarValue = document.getElementById("swingVarValue");
    const pulse = document.getElementById("pulse");
    const pulseValue = document.getElementById("pulseValue");
    const detune = document.getElementById("detune");
    const detuneValue = document.getElementById("detuneValue");
    const mod = document.getElementById("mod");
    const modValue = document.getElementById("modValue");
    const chaos = document.getElementById("chaos");
    const chaosValue = document.getElementById("chaosValue");
    const pressure = document.getElementById("pressure");
    const pressureValue = document.getElementById("pressureValue");
    const headroomMode = document.getElementById("headroomMode");
    const headroomAmount = document.getElementById("headroomAmount");
    const headroomAmountValue = document.getElementById("headroomAmountValue");
    const stressFill = document.getElementById("stressFill");
    const stressText = document.getElementById("stressText");
    const densityReactInfo = document.getElementById("densityReactInfo");
    const sagInfo = document.getElementById("sagInfo");
    const velocityCrushMode = document.getElementById("velocityCrushMode");
    const dryMode = document.getElementById("dryMode");
    const fxFocus = document.getElementById("fxFocus");
    const fxFocusInfo = document.getElementById("fxFocusInfo");
    const evolutionAmountSlider = document.getElementById("evolutionAmount");
    const evolutionAmountValue = document.getElementById("evolutionAmountValue");
    const evolutionMemoryInfo = document.getElementById("evolutionMemoryInfo");
    const tensorEnable = document.getElementById("tensorEnable");
    const tensorBlend = document.getElementById("tensorBlend");
    const tensorBlendValue = document.getElementById("tensorBlendValue");
    const tensorSpeed = document.getElementById("tensorSpeed");
    const tensorSpeedValue = document.getElementById("tensorSpeedValue");
    const tensorPitch = document.getElementById("tensorPitch");
    const tensorPitchValue = document.getElementById("tensorPitchValue");
    const tensorStretch = document.getElementById("tensorStretch");
    const tensorStretchValue = document.getElementById("tensorStretchValue");
    const tensorStopTime = document.getElementById("tensorStopTime");
    const tensorStopValue = document.getElementById("tensorStopValue");
    const tensorReverseMode = document.getElementById("tensorReverseMode");
    const tensorReverseHold = document.getElementById("tensorReverseHold");
    const tensorReverseLatch = document.getElementById("tensorReverseLatch");
    const tensorFreeze = document.getElementById("tensorFreeze");
    const tensorLoopLength = document.getElementById("tensorLoopLength");
    const tensorLoopValue = document.getElementById("tensorLoopValue");
    const tensorRandomAmount = document.getElementById("tensorRandomAmount");
    const tensorRandomValue = document.getElementById("tensorRandomValue");
    const tensorRandomTrigger = document.getElementById("tensorRandomTrigger");
    const tensorTriggerValue = document.getElementById("tensorTriggerValue");
    const tensorSmooth = document.getElementById("tensorSmooth");
    const tensorSmoothValue = document.getElementById("tensorSmoothValue");
    const tensorStatus = document.getElementById("tensorStatus");
    const sketchGroove = document.getElementById("sketchGroove");
    const sketchDensity = document.getElementById("sketchDensity");
    const sketchAccent = document.getElementById("sketchAccent");
    const sketchHumanize = document.getElementById("sketchHumanize");
    const houseFlavor = document.getElementById("houseFlavor");
    const technoFlavor = document.getElementById("technoFlavor");
    const hiphopFlavor = document.getElementById("hiphopFlavor");
    const sketchSurprise = document.getElementById("sketchSurprise");
    const quickVariation = document.getElementById("quickVariation");
    const quickVariationValue = document.getElementById("quickVariationValue");
    const genreVariation = document.getElementById("genreVariation");
    const genreVariationValue = document.getElementById("genreVariationValue");
    const quickSketchSummary = document.getElementById("quickSketchSummary");
    const genreSketchSummary = document.getElementById("genreSketchSummary");
    const paletteList = document.getElementById("paletteList");
    const xyPad = document.getElementById("xyPad");
    const xyCrosshair = document.getElementById("xyCrosshair");
    const xyHandle = document.getElementById("xyHandle");
    const stepLabel = document.getElementById("stepLabel");
    const stepChance = document.getElementById("stepChance");
    const stepEvery = document.getElementById("stepEvery");
    const chanceValue = document.getElementById("chanceValue");
    const everyValue = document.getElementById("everyValue");
    const lockPitch = document.getElementById("lockPitch");
    const lockPitchEnable = document.getElementById("lockPitchEnable");
    const lockPitchValue = document.getElementById("lockPitchValue");
    const lockReverse = document.getElementById("lockReverse");
    const lockReverseValue = document.getElementById("lockReverseValue");
    const lockSlice = document.getElementById("lockSlice");
    const lockSliceEnable = document.getElementById("lockSliceEnable");
    const lockSliceValue = document.getElementById("lockSliceValue");
    const lockStretch = document.getElementById("lockStretch");
    const lockStretchEnable = document.getElementById("lockStretchEnable");
    const lockStretchValue = document.getElementById("lockStretchValue");
    const lockFilter = document.getElementById("lockFilter");
    const lockFilterEnable = document.getElementById("lockFilterEnable");
    const lockFilterValue = document.getElementById("lockFilterValue");
    const lockRes = document.getElementById("lockRes");
    const lockResEnable = document.getElementById("lockResEnable");
    const lockResValue = document.getElementById("lockResValue");
    const lockDecay = document.getElementById("lockDecay");
    const lockDecayEnable = document.getElementById("lockDecayEnable");
    const lockDecayValue = document.getElementById("lockDecayValue");
    const lockFx = document.getElementById("lockFx");
    const lockFxEnable = document.getElementById("lockFxEnable");
    const lockFxValue = document.getElementById("lockFxValue");
    const clearLocks = document.getElementById("clearLocks");
    const recordButton = document.getElementById("record");
    const exportWavButton = document.getElementById("exportWav");
    const recordStatus = document.getElementById("recordStatus");

    function wrapIndex(index, len) {
      let out = index % len;
      if (out < 0) out += len;
      return out;
    }

    function readRingSample(buffer, pos) {
      const len = buffer.length;
      const a = Math.floor(pos);
      const b = wrapIndex(a + 1, len);
      const frac = pos - a;
      const av = buffer[wrapIndex(a, len)] || 0;
      const bv = buffer[b] || 0;
      return av + (bv - av) * frac;
    }

    function findZeroCrossingInTensor(center, radius) {
      if (!tensorState.left || !tensorState.right || tensorState.bufferLen < 8) return center;
      const len = tensorState.bufferLen;
      const search = Math.max(8, Math.floor(radius));
      let bestPos = center;
      let bestScore = Number.POSITIVE_INFINITY;
      for (let i = -search; i <= search; i++) {
        const p = wrapIndex(center + i, len);
        const p1 = wrapIndex(p + 1, len);
        const a = 0.5 * (tensorState.left[p] + tensorState.right[p]);
        const b = 0.5 * (tensorState.left[p1] + tensorState.right[p1]);
        const score = Math.abs(a) + Math.abs(b) + Math.abs(a - b) * 0.6;
        if (score < bestScore) {
          bestScore = score;
          bestPos = p;
        }
      }
      return bestPos;
    }

    function ensureTensorBuffer(sampleRate) {
      if (!sampleRate) return;
      const targetLen = Math.max(1024, Math.floor(sampleRate * 9.4));
      if (tensorState.left && tensorState.bufferLen === targetLen && tensorState.sampleRate === sampleRate) return;
      tensorState.sampleRate = sampleRate;
      tensorState.bufferLen = targetLen;
      tensorState.left = new Float32Array(targetLen);
      tensorState.right = new Float32Array(targetLen);
      tensorState.writePos = 0;
      tensorState.readPos = targetLen / 2;
      tensorState.prevReadPos = tensorState.readPos;
      tensorState.pitchPhase = 0;
      tensorState.currentSpeed = tensorState.speed || 1.0;
    }

    function getTensorTargetSpeed() {
      let target = tensorState.speed;
      if (tensorState.reverseMode === "momentary" && tensorState.reverseHeld) {
        target = -Math.abs(target || 1);
      }
      if (tensorState.reverseMode === "latch" && tensorState.reverseLatched) {
        target = -Math.abs(target || 1);
      }
      return target;
    }

    function updateTensorStatus() {
      if (!tensorStatus) return;
      const direction = tensorState.currentSpeed >= 0 ? "FWD" : "REV";
      const freeze = tensorState.freeze ? "FREEZE" : "LIVE";
      const loopMs = Math.round(tensorState.loopMs);
      const blend = Math.round(tensorState.blend * 100);
      const activeTracks = trackState.filter((track) => track.tensorEnabled).length;
      tensorStatus.textContent = tensorState.enabled
        ? `${freeze} • ${direction} • ${loopMs}ms • Wet ${blend}% • Tracks ${activeTracks}`
        : "Tensor idle";
    }

    function createTensorProcessor(trackIndex) {
      const runtime = {
        writePos: 0,
        readPos: 0,
        currentSpeed: 1,
        pitchPhase: 0,
        bufferLen: 0,
        sampleRate: 48000,
        data: null,
        crossfadeSamples: 128,
        crossfadeRemaining: 0,
        prevReadPos: 0
      };
      const node = audioContext.createScriptProcessor(1024, 1, 1);
      node.onaudioprocess = (event) => {
        const sampleRate = event.inputBuffer.sampleRate || audioContext.sampleRate;
        const targetLen = Math.max(1024, Math.floor(sampleRate * 4.7));
        if (!runtime.data || runtime.bufferLen !== targetLen || runtime.sampleRate !== sampleRate) {
          runtime.sampleRate = sampleRate;
          runtime.bufferLen = targetLen;
          runtime.data = new Float32Array(targetLen);
          runtime.writePos = 0;
          runtime.readPos = targetLen / 2;
          runtime.prevReadPos = runtime.readPos;
          runtime.pitchPhase = 0;
          runtime.currentSpeed = tensorState.speed || 1.0;
        }
        const inL = event.inputBuffer.getChannelData(0);
        const outL = event.outputBuffer.getChannelData(0);
        const len = runtime.bufferLen;
        const loopSamples = clamp(Math.floor((tensorState.loopMs / 1000) * sampleRate), 256, len - 1);
        const smoothSamples = Math.max(24, Math.floor(24 + tensorState.smooth * 640));
        const trackTensorEnabled = trackState[trackIndex] ? trackState[trackIndex].tensorEnabled : false;
        const dryAppliesToTrack = dryModeEnabled && trackIndex === selectedTrackIndex;
        const focusAllowsTensor = dryAppliesToTrack
          ? fxFocusEffect === "tensor"
          : (tensorState.enabled && trackTensorEnabled);

        if (focusAllowsTensor && !tensorState.freeze) {
          const triggerProb = clamp(tensorState.randomTrigger * (0.1 + tensorState.randomAmount * 0.9), 0, 1);
          if (Math.random() < triggerProb * 0.25) {
            const candidate = wrapIndex(runtime.writePos - Math.floor(Math.random() * loopSamples), len);
            const snapped = wrapIndex(candidate, len);
            runtime.prevReadPos = runtime.readPos;
            runtime.readPos = snapped;
            runtime.crossfadeRemaining = smoothSamples;
          }
        }

        for (let i = 0; i < inL.length; i++) {
          const dryL = inL[i];
          runtime.data[runtime.writePos] = dryL;

          if (!focusAllowsTensor) {
            outL[i] = dryL;
            runtime.writePos = wrapIndex(runtime.writePos + 1, len);
            continue;
          }

          const targetSpeed = getTensorTargetSpeed();
          const stopSamples = Math.max(1, Math.floor((tensorState.stopTimeMs / 1000) * sampleRate));
          runtime.currentSpeed += (targetSpeed - runtime.currentSpeed) / stopSamples;
          const timeSpeed = tensorState.freeze ? 0 : (runtime.currentSpeed * tensorState.stretch);
          runtime.readPos = wrapIndex(runtime.readPos + timeSpeed, len);

          const behind = wrapIndex(runtime.writePos - runtime.readPos, len);
          if (behind > loopSamples) {
            runtime.readPos = wrapIndex(runtime.writePos - Math.floor(loopSamples * 0.5), len);
          }

          const pitchFactor = Math.pow(2, tensorState.pitchSemitones / 12);
          runtime.pitchPhase += (pitchFactor - 1) * 0.15;
          runtime.pitchPhase = clamp(runtime.pitchPhase, -loopSamples * 0.25, loopSamples * 0.25);
          const srcPos = wrapIndex(runtime.readPos + runtime.pitchPhase, len);

          let wetL = readRingSample(runtime.data, srcPos);
          if (runtime.crossfadeRemaining > 0) {
            const t = 1 - (runtime.crossfadeRemaining / smoothSamples);
            const prevPos = wrapIndex(runtime.prevReadPos + timeSpeed, len);
            const prevL = readRingSample(runtime.data, prevPos);
            wetL = prevL + (wetL - prevL) * t;
            runtime.prevReadPos = prevPos;
            runtime.crossfadeRemaining -= 1;
          }

          const wetAmt = tensorState.blend;
          const dryAmt = 1 - wetAmt;
          outL[i] = dryL * dryAmt + wetL * wetAmt;
          runtime.writePos = wrapIndex(runtime.writePos + 1, len);
        }
      };
      return node;
    }

    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioContext.createGain();
        masterGain.gain.value = 0.6;

        masterCompressor = audioContext.createDynamicsCompressor();
        masterCompressor.threshold.value = -22;
        masterCompressor.knee.value = 10;
        masterCompressor.ratio.value = 4.5;
        masterCompressor.attack.value = 0.003;
        masterCompressor.release.value = 0.16;

        masterSaturation = createWaveshaper(0.95);
        masterLimiter = audioContext.createDynamicsCompressor();
        masterLimiter.threshold.value = -3;
        masterLimiter.knee.value = 0;
        masterLimiter.ratio.value = 20;
        masterLimiter.attack.value = 0.001;
        masterLimiter.release.value = 0.08;
        updateTape();
        reverbImpulse = createReverbImpulse(2.2, 2.0);

        characterPreGain = audioContext.createGain();
        characterPreGain.gain.value = characterBaseDrive;

        characterFilter1 = audioContext.createBiquadFilter();
        characterFilter1.type = "lowpass";
        characterFilter1.frequency.value = 12000;
        characterFilter1.Q.value = characterBaseQ;

        characterFilter2 = audioContext.createBiquadFilter();
        characterFilter2.type = "lowpass";
        characterFilter2.frequency.value = 12000;
        characterFilter2.Q.value = characterBaseQ * 0.85;

        characterPostGain = audioContext.createGain();
        characterPostGain.gain.value = 1.0;

        energyAnalyser = audioContext.createAnalyser();
        energyAnalyser.fftSize = 256;
        energyData = new Float32Array(energyAnalyser.fftSize);

        trackState.forEach((track, index) => {
          track.trackOut = audioContext.createGain();
          track.trackOut.gain.value = track.volume;
          track.fxNodes = createTrackFxNodes(index);
          track.fxNodes.output.connect(track.trackOut);
          track.trackOut.connect(masterGain);
        });

        masterGain
          .connect(characterPreGain)
          .connect(characterFilter1)
          .connect(characterFilter2)
          .connect(characterPostGain);

        characterPostGain.connect(energyAnalyser);
        characterPostGain
          .connect(masterCompressor)
          .connect(masterSaturation);
        masterSaturation
          .connect(masterLimiter)
          .connect(audioContext.destination);
      }
    }

    function initRecorder() {
      if (recorderNode) return;
      recorderNode = audioContext.createScriptProcessor(4096, 2, 2);
      recorderNode.onaudioprocess = (event) => {
        if (!isRecording) return;
        const inputL = event.inputBuffer.getChannelData(0);
        const inputR = event.inputBuffer.numberOfChannels > 1
          ? event.inputBuffer.getChannelData(1)
          : inputL;
        recordBuffersL.push(new Float32Array(inputL));
        recordBuffersR.push(new Float32Array(inputR));
        recordLength += inputL.length;
      };
      recorderMonitor = audioContext.createGain();
      recorderMonitor.gain.value = 0;
      const tapSource = masterLimiter || masterSaturation;
      tapSource.connect(recorderNode);
      recorderNode.connect(recorderMonitor).connect(audioContext.destination);
    }

    function startRecording() {
      initAudio();
      initRecorder();
      recordBuffersL = [];
      recordBuffersR = [];
      recordLength = 0;
      isRecording = true;
      recordStatus.textContent = "Recording...";
      recordButton.classList.add("active");
    }

    function stopRecording() {
      if (!isRecording) return;
      isRecording = false;
      recordButton.classList.remove("active");
      recordStatus.textContent = recordLength > 0 ? "Ready to export" : "Idle";
    }

    function mergeBuffers(buffers, length) {
      const result = new Float32Array(length);
      let offset = 0;
      buffers.forEach((buffer) => {
        result.set(buffer, offset);
        offset += buffer.length;
      });
      return result;
    }

    function encodeWav(left, right, sampleRate) {
      const numChannels = 2;
      const length = left.length;
      const interleaved = new Float32Array(length * numChannels);
      for (let i = 0; i < length; i++) {
        interleaved[i * 2] = left[i];
        interleaved[i * 2 + 1] = right[i];
      }

      const buffer = new ArrayBuffer(44 + interleaved.length * 2);
      const view = new DataView(buffer);

      function writeString(offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }

      let offset = 0;
      writeString(offset, "RIFF"); offset += 4;
      view.setUint32(offset, 36 + interleaved.length * 2, true); offset += 4;
      writeString(offset, "WAVE"); offset += 4;
      writeString(offset, "fmt "); offset += 4;
      view.setUint32(offset, 16, true); offset += 4;
      view.setUint16(offset, 1, true); offset += 2;
      view.setUint16(offset, numChannels, true); offset += 2;
      view.setUint32(offset, sampleRate, true); offset += 4;
      view.setUint32(offset, sampleRate * numChannels * 2, true); offset += 4;
      view.setUint16(offset, numChannels * 2, true); offset += 2;
      view.setUint16(offset, 16, true); offset += 2;
      writeString(offset, "data"); offset += 4;
      view.setUint32(offset, interleaved.length * 2, true); offset += 4;

      for (let i = 0; i < interleaved.length; i++, offset += 2) {
        const s = Math.max(-1, Math.min(1, interleaved[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      }
      return buffer;
    }

    function exportWav() {
      if (!audioContext || recordLength === 0) {
        recordStatus.textContent = "No take";
        return;
      }
      const left = mergeBuffers(recordBuffersL, recordLength);
      const right = mergeBuffers(recordBuffersR, recordLength);
      const wavBuffer = encodeWav(left, right, audioContext.sampleRate);
      const blob = new Blob([wavBuffer], { type: "audio/wav" });
      const url = URL.createObjectURL(blob);
      const anchor = document.createElement("a");
      const stamp = new Date().toISOString().replace(/[:.]/g, "-");
      anchor.href = url;
      anchor.download = `drm-mchn-${stamp}.wav`;
      anchor.click();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      recordStatus.textContent = "Exported";
    }

    function updateTape() {
      const driftedTape = clamp((Number(tape.value) / 100) + longDrift * 0.05, 0, 1.2);
      const amount = (0.9 + driftedTape * 0.9) * preSaturationDrive;
      masterSaturation.curve = createSaturationCurve(amount);
    }

    async function loadSample(trackIndex, file) {
      initAudio();
      const arrayBuffer = await file.arrayBuffer();
      const buffer = await audioContext.decodeAudioData(arrayBuffer);
      trackState[trackIndex].buffer = buffer;
      trackState[trackIndex].reverseBuffer = createReverseBuffer(buffer);
      trackState[trackIndex].source = "sample";
      const label = document.getElementById(`sourceVal-${trackIndex}`);
      if (label) label.textContent = "Sample";
    }

    function createReverseBuffer(buffer) {
      const reversed = audioContext.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
      for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
        const data = buffer.getChannelData(channel);
        const reversedData = reversed.getChannelData(channel);
        for (let i = 0; i < data.length; i++) {
          reversedData[i] = data[data.length - 1 - i];
        }
      }
      return reversed;
    }

    async function initLiveInput() {
      if (trackState.some((track) => track.liveNode)) return;
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      trackState.forEach((track) => {
        track.liveNode = audioContext.createMediaStreamSource(stream);
        track.liveGain = audioContext.createGain();
        track.liveGain.gain.value = 0;
        track.liveNode.connect(track.liveGain);
      });
    }

    function resampleTrack(trackIndex) {
      initAudio();
      if (typeof MediaRecorder === "undefined") {
        console.warn("MediaRecorder not supported in this browser/context.");
        return;
      }
      const recordLength = (60 / Number(tempo.value)) * 4; // 1 bar
      const dest = audioContext.createMediaStreamDestination();
      const recorder = new MediaRecorder(dest.stream);
      const chunks = [];
      recorder.ondataavailable = (event) => chunks.push(event.data);
      recorder.onstop = async () => {
        const blob = new Blob(chunks, { type: "audio/webm" });
        const arrayBuffer = await blob.arrayBuffer();
        const buffer = await audioContext.decodeAudioData(arrayBuffer);
        trackState[trackIndex].resampleBuffer = buffer;
        trackState[trackIndex].reverseBuffer = createReverseBuffer(buffer);
        trackState[trackIndex].source = "resample";
        const label = document.getElementById(`sourceVal-${trackIndex}`);
        if (label) label.textContent = "Resample";
      };

      const tap = audioContext.createGain();
      tap.gain.value = 1;
      tap.connect(dest);
      trackState[trackIndex].trackOut.connect(tap);
      try { recorder.start(); } catch (err) { console.error("Resample start error:", err); }
      setTimeout(() => {
        try { recorder.stop(); } catch (err) { console.error("Resample stop error:", err); }
        try { trackState[trackIndex].trackOut.disconnect(tap); } catch (err) {}
      }, recordLength * 1000);
    }

    function resampleMaster() {
      initAudio();
      if (typeof MediaRecorder === "undefined") {
        console.warn("MediaRecorder not supported in this browser/context.");
        return;
      }
      if (isResamplingMaster) return;
      isResamplingMaster = true;
      const resampleButton = document.getElementById("resampleMaster");
      if (resampleButton) {
        resampleButton.classList.add("active");
        resampleButton.textContent = "Resampling...";
      }
      const recordLength = (60 / Number(tempo.value)) * 4;
      const dest = audioContext.createMediaStreamDestination();
      const recorder = new MediaRecorder(dest.stream);
      const chunks = [];
      recorder.ondataavailable = (event) => chunks.push(event.data);
      recorder.onstop = async () => {
        const blob = new Blob(chunks, { type: "audio/webm" });
        const arrayBuffer = await blob.arrayBuffer();
        const buffer = await audioContext.decodeAudioData(arrayBuffer);
        trackState[0].resampleBuffer = buffer;
        trackState[0].reverseBuffer = createReverseBuffer(buffer);
        trackState[0].source = "resample";
        const label = document.getElementById("sourceVal-0");
        if (label) label.textContent = "Resample";
      };
      const tap = audioContext.createGain();
      tap.gain.value = 1;
      tap.connect(dest);
      const tapSource = masterLimiter || masterSaturation || masterGain;
      tapSource.connect(tap);
      try { recorder.start(); } catch (err) { console.error("Master resample start error:", err); }
      setTimeout(() => {
        try { recorder.stop(); } catch (err) { console.error("Master resample stop error:", err); }
        try { tapSource.disconnect(tap); } catch (err) {}
        isResamplingMaster = false;
        if (resampleButton) {
          resampleButton.classList.remove("active");
          resampleButton.textContent = "Resample Master";
        }
      }, recordLength * 1000);
    }

    function schedule() {
      try {
        while (nextNoteTime < audioContext.currentTime + 0.14) {
          playStep(currentStep, nextNoteTime);
          advanceStep();
        }
      } catch (err) {
        console.error("Scheduler error:", err);
      }
      schedulerId = requestAnimationFrame(schedule);
    }

    function advanceStep() {
      // Humanized swing drift: slow random walk so swing breathes.
      swingDriftState += randomInRange(-0.6, 0.6);
      swingDriftState = clamp(swingDriftState, -humanize.swingVar, humanize.swingVar);

      // Pulse drift: slow BPM wobble around the base tempo.
      pulseDriftState += randomInRange(-0.03, 0.03) * humanize.pulseDrift;
      pulseDriftState = clamp(pulseDriftState, -humanize.pulseDrift, humanize.pulseDrift);

      const bpm = Math.max(40, Number(tempo.value) + pulseDriftState);
      const secondsPerBeat = 60.0 / bpm;
      const stepDuration = secondsPerBeat / 4;
      const swingOffset = (currentStep % 2 === 1 ? (Number(swing.value) + swingDriftState + longDrift * 3) : 0) / 1000;

      nextNoteTime += stepDuration + swingOffset;
      currentStep = (currentStep + 1) % steps;
    }

    function playStep(stepIndex, time) {
      if (stepIndex === 0) {
        longDrift += randomInRange(-0.005, 0.005);
        longDrift = clamp(longDrift, -0.15, 0.15);
        evolveCurrentBar();
      }
      const stepButtons = document.querySelectorAll(`.step[data-step="${stepIndex}"]`);
      stepButtons.forEach((btn) => btn.classList.add("current"));
      setTimeout(() => stepButtons.forEach((btn) => btn.classList.remove("current")), 80);

      const bpm = Math.max(40, Number(tempo.value) + pulseDriftState);
      const stepDuration = (60.0 / bpm) / 4;
      let timingCompression = 1.0;
      const hits = [];
      let maxAccent = 0;
      let shouldTriggerCharacter = false;
      const hasSolo = trackState.some((state) => state.solo);
      const probChaos = chaosAmount("probability");
      const densityChaos = chaosAmount("density");
      const densityTighten = clamp01(densityReactAmount * behavior.density);
      const loosenessScale = 1 - 0.6 * densityTighten;
      const velocityVarScale = 1 - 0.4 * densityTighten;

      tracks.forEach((track, tIndex) => {
        if (hasSolo && !trackState[tIndex].solo) return;
        if (trackState[tIndex].mute) return;
        const cycle = trackState[tIndex].cycle;
        const localStep = stepIndex % cycle;
        if (localStep === 0) trackLoopCount[tIndex] += 1;
        const data = sequence[tIndex][localStep];
        if (!data.on) return;
        const chanceJitter = (Math.random() * 2 - 1) * 22 * probChaos;
        const chanceNow = clamp(data.cond.chance + chanceJitter, 0, 100);
        if (Math.random() * 100 > chanceNow) return;
        const everyNow = probChaos > 0 ? Math.max(1, data.cond.every + (Math.random() < probChaos * 0.2 ? 1 : 0)) : data.cond.every;
        if (everyNow > 1 && (trackLoopCount[tIndex] % everyNow !== 0)) return;

        // Beatdown microtiming + humanize offset applied here.
        const microTime = (data.offset / 1000);
        const humanTime = (data.humanOffset / 1000) * loosenessScale;
        const velocity = data.velocity * (1 + (data.humanVel - 1) * velocityVarScale);
        if (velocity > maxAccent) maxAccent = velocity;
        hits.push({ track, tIndex, data, microTime, humanTime, velocity });
        shouldTriggerCharacter = true;
        if (densityChaos > 0 && !isDownbeat(localStep) && Math.random() < 0.04 * densityChaos) {
          hits.push({ track, tIndex, data, microTime: microTime + 0.006, humanTime, velocity: velocity * 0.45 });
        }
      });

      // ---- Behavior inputs (per step) ----
      // Energy is already tracked elsewhere as energyValue (0..1-ish)
      behavior.energy = clamp01(typeof energyValue !== "undefined" ? energyValue : 0);

      // Density from actual triggered hits (pre-sketch-safe since you currently use hits directly)
      const densityStep = clamp01(hits.length / 6);
      behavior.density = lerp(behavior.density, densityStep, 0.15);

      // Cluster from micro/human offsets of hits
      let clusterStep = 0;
      if (hits.length >= 2) {
        const times = hits
          .map((h) => h.microTime + h.humanTime)
          .sort((a, b) => a - b);

        let minGap = Infinity;
        for (let i = 1; i < times.length; i++) {
          minGap = Math.min(minGap, times[i] - times[i - 1]);
        }

        clusterStep =
          minGap <= 0.015 ? 1 :
          minGap <= 0.030 ? (1 - (minGap - 0.015) / 0.015) :
          0;
      }
      behavior.cluster = lerp(behavior.cluster, clusterStep, 0.10);

      // Impulse from strongest accent this step
      behavior.impulse = lerp(behavior.impulse, clamp01(maxAccent), 0.35);

      // Update Stress/Heat + derived outputs
      updateStressHeat();
      updateStressVisual();

      // Now derive timing compression from behavior (caps tighten)
      timingCompression = 1 - (0.55 * Math.pow(behavior.stress, 1.6));

      const modDeltas = getModMatrixDeltas(hits.length, maxAccent);
      const headroomProfile = getHeadroomStepProfile(hits);
      if (masterSaturation) updateTape();

      if (shouldTriggerCharacter && hits.length > 0) {
        const scaledAccent = Math.max(0.6, Math.min(1.4, maxAccent + transientAccentBoost));
        triggerCharacterEnvelope(time, scaledAccent);
      }

      hits.forEach((hit) => {
        const coupledVelocity = applyHeadroomToVelocity(hit, hit.velocity, headroomProfile);
        try {
          triggerSound(
            hit.track.tone,
            time + (hit.microTime + hit.humanTime) * timingCompression,
            hit.tIndex,
            coupledVelocity,
            hit.data,
            stepDuration,
            modDeltas
          );
        } catch (err) {
          console.error("Trigger error:", err);
        }

        const stutterCap = hits.length > 6 ? 0.1 : hits.length > 4 ? 0.16 : 0.25;
        const stutterChance = Math.min(trackState[hit.tIndex].stutter + densityChaos * 0.05, stutterCap);
        if (Math.random() < stutterChance) {
          try {
            triggerSound(
              hit.track.tone,
              time + (hit.microTime + hit.humanTime) * timingCompression + 0.03,
              hit.tIndex,
              coupledVelocity * 0.6,
              hit.data,
              stepDuration,
              modDeltas
            );
          } catch (err) {
            console.error("Stutter error:", err);
          }
        }
      });
    }

    function triggerSound(type, time, tIndex, velocity, data, stepDuration, modDeltas = null) {
      const state = trackState[tIndex];
      const layerEnergyBoost = modDeltas ? modDeltas.energyToNoise : 0;
      const dryAppliesToTrack = dryModeEnabled && tIndex === selectedTrackIndex;
      const layerChance = (dryAppliesToTrack && fxFocusEffect === "none")
        ? 0
        : clamp(Number(layer.value) / 100 + behavior.noiseBoost + layerEnergyBoost * 0.5, 0, 0.75);

      const chaosScale = chaosAmount("tone");
      const rawStyle = state.style || "lofi";
      const style = rawStyle === "random" ? pickVariant(["lofi", "metallic", "dirty", "soft"]) : rawStyle;
      const styleProfile = getStyleProfile(style);

      const lockedPitch = getLockedValue(data, "pitch", state.pitch + data.humanDetune);
      const lockedSlice = getLockedValue(data, "slice", state.slice);
      const lockedStretch = getLockedValue(data, "stretch", state.stretch);
      const lockedFilter = getLockedValue(data, "filter", state.filter);
      const lockedRes = getLockedValue(data, "resonance", state.resonance);
      const lockedDecay = getLockedValue(data, "decay", clamp(state.decay + data.humanMod * 0.4, 0.05, 1.2));
      const lockedFx = getLockedValue(data, "fx", state.fx);
      const reverse = data.locks.reverse === true;

      const cutoffDelta = modDeltas ? modDeltas.densityToCutoff : 0;
      const resDelta = modDeltas ? modDeltas.swingToRes : 0;
      const styledFilter = clamp(lockedFilter * (1 + styleProfile.filter * chaosScale) + cutoffDelta, 300, 8000);
      const styledRes = clamp(lockedRes * (1 + styleProfile.res * chaosScale) + resDelta, 0.1, 12);
      const styledDecay = clamp(lockedDecay * (1 + styleProfile.decay * chaosScale), 0.05, 1.2);
      const chaosCrushDelta = modDeltas ? modDeltas.chaosToCrush : 0;
      const styledState = {
        ...state,
        dist: clamp(state.dist + styleProfile.dist * chaosScale, 0, 1),
        crush: computeVelocityCrush(clamp(state.crush + styleProfile.crush * chaosScale, 0, 1), velocity, chaosCrushDelta),
        delay: clamp(state.delay + styleProfile.delay * chaosScale, 0, 1),
        reverb: clamp(state.reverb + styleProfile.reverb * chaosScale, 0, 1),
        fx: clamp(state.fx + styleProfile.fx * chaosScale, 0, 1),
        lfo: clamp(state.lfo + styleProfile.lfo * chaosScale, 0, 1)
      };

      const chain = state.fxNodes;
      updateTrackFx(chain, styledFilter, styledRes, styledState, clamp(lockedFx + styleProfile.fx * chaosScale, 0, 1), time);

      const envGain = audioContext.createGain();
      const vel = clamp(velocity, 0.05, 1.0);
      envGain.gain.setValueAtTime(0.0001, time);
      envGain.gain.exponentialRampToValueAtTime(vel, time + 0.01);
      envGain.gain.exponentialRampToValueAtTime(0.0001, time + styledDecay);

      envGain.connect(chain.input);

      if (state.source === "live" && state.liveGain) {
        // Gate live input through step envelope.
        state.liveGain.connect(envGain);
        setTimeout(() => {
          try { state.liveGain.disconnect(envGain); } catch (err) {}
        }, Math.max(100, lockedDecay * 1000));
      } else {
        const buffer = state.source === "resample" ? state.resampleBuffer : state.buffer;
        const reverseBuffer = state.source === "resample" ? state.reverseBuffer : state.reverseBuffer;
        if (buffer) {
          const targetBuffer = reverse ? reverseBuffer || buffer : buffer;
          playSample(targetBuffer, time, envGain, lockedPitch, lockedSlice, lockedStretch, stepDuration);
        } else {
          // Fallback to beatdown synths if no buffer loaded.
          const toneState = { pitch: lockedPitch, decay: styledDecay, lfo: styledState.lfo };
          if (type === "kick") synthKickLoFi(time, toneState, envGain);
          if (type === "snare") synthSnareLoFi(time, toneState, envGain);
          if (type === "hat") synthHatLoFi(time, toneState, envGain);
          if (type === "clap") synthClapLoFi(time, toneState, envGain);
          if (type === "tom") synthTomLoFi(time, toneState, envGain);
          if (type === "perc") synthPercLoFi(time, toneState, envGain);
          if (type === "ride") synthRideLoFi(time, toneState, envGain);
          if (type === "fx") synthFxLoFi(time, toneState, envGain);
        }
      }

      // Random layered noise for dusty texture and field-recording vibe.
      if (Math.random() < layerChance) {
        synthDustLayer(time, chain.input, 0.2 * velocity);
      }
    }
        function synthKickLoFi(time, state, output) {
      const drive = createWaveshaper(1 + (state.lfo || 0) * 2);
      const body = audioContext.createOscillator();
      const bodyGain = audioContext.createGain();
      const sub = audioContext.createOscillator();
      const subGain = audioContext.createGain();
      const lp = audioContext.createBiquadFilter();
      lp.type = "lowpass";
      lp.frequency.setValueAtTime(900, time);

      const base = midiToFreq(36 + state.pitch);
      const drop = midiToFreq(22 + state.pitch);
      body.type = "sine";
      body.frequency.setValueAtTime(base, time);
      body.frequency.exponentialRampToValueAtTime(drop, time + 0.08 + state.decay * 0.06);
      bodyGain.gain.setValueAtTime(1.05, time);
      bodyGain.gain.exponentialRampToValueAtTime(0.0001, time + 0.45 + state.decay * 0.6);

      sub.type = "sine";
      sub.frequency.setValueAtTime(base * 0.5, time);
      subGain.gain.setValueAtTime(0.6, time);
      subGain.gain.exponentialRampToValueAtTime(0.0001, time + 0.5 + state.decay * 0.7);

      body.connect(bodyGain).connect(drive).connect(lp).connect(output);
      sub.connect(subGain).connect(output);

      const click = audioContext.createBufferSource();
      click.buffer = createNoiseBuffer();
      const clickFilter = audioContext.createBiquadFilter();
      clickFilter.type = "highpass";
      clickFilter.frequency.value = 2400 + randomInRange(-200, 200);
      const clickGain = audioContext.createGain();
      clickGain.gain.setValueAtTime(0.28, time);
      clickGain.gain.exponentialRampToValueAtTime(0.001, time + 0.045);
      click.connect(clickFilter).connect(clickGain).connect(output);

      body.start(time);
      sub.start(time);
      click.start(time);
      body.stop(time + 1.0);
      sub.stop(time + 1.0);
      click.stop(time + 0.08);
    }

    function synthSnareLoFi(time, state, output) {
      const noise = audioContext.createBufferSource();
      noise.buffer = createNoiseBuffer();
      const band = audioContext.createBiquadFilter();
      band.type = "bandpass";
      band.frequency.value = 2000 + randomInRange(-200, 200);
      band.Q.value = 0.8;
      const snap = audioContext.createBiquadFilter();
      snap.type = "highpass";
      snap.frequency.value = 3200;
      const noiseGain = audioContext.createGain();
      noiseGain.gain.setValueAtTime(0.6, time);
      noiseGain.gain.exponentialRampToValueAtTime(0.001, time + 0.28 + state.decay * 0.4);

      const tone1 = audioContext.createOscillator();
      const tone2 = audioContext.createOscillator();
      const toneGain = audioContext.createGain();
      tone1.type = "triangle";
      tone2.type = "sine";
      const base = midiToFreq(48 + state.pitch);
      tone1.frequency.setValueAtTime(base, time);
      tone1.frequency.exponentialRampToValueAtTime(base * 0.9, time + 0.1);
      tone2.frequency.setValueAtTime(base * 1.52, time);
      tone2.frequency.exponentialRampToValueAtTime(base * 1.2, time + 0.08);

      toneGain.gain.setValueAtTime(0.38, time);
      toneGain.gain.exponentialRampToValueAtTime(0.001, time + 0.25 + state.decay * 0.3);

      const grit = createWaveshaper(0.8 + (state.lfo || 0) * 1.6);
      noise.connect(band).connect(grit).connect(noiseGain).connect(output);
      noise.connect(snap).connect(noiseGain).connect(output);
      tone1.connect(toneGain);
      tone2.connect(toneGain);
      toneGain.connect(output);

      noise.start(time);
      tone1.start(time);
      tone2.start(time);
      noise.stop(time + 0.7);
      tone1.stop(time + 0.7);
      tone2.stop(time + 0.7);
    }

    function synthHatLoFi(time, state, output) {
      const ratios = [1, 1.34, 1.5, 1.8, 2.45, 2.7];
      const base = 400 + randomInRange(-40, 40);
      const mix = audioContext.createGain();
      mix.gain.value = 0.6;

      ratios.forEach((ratio) => {
        const osc = audioContext.createOscillator();
        osc.type = "square";
        osc.frequency.setValueAtTime(base * ratio, time);
        osc.connect(mix);
        osc.start(time);
        osc.stop(time + 0.35);
      });

      const noise = audioContext.createBufferSource();
      noise.buffer = createNoiseBuffer();
      const hp = audioContext.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.value = 5200;
      const bp = audioContext.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.value = 7200;
      bp.Q.value = 0.7;

      const env = audioContext.createGain();
      env.gain.setValueAtTime(0.35, time);
      env.gain.exponentialRampToValueAtTime(0.001, time + 0.12 + state.decay * 0.2);

      mix.connect(hp).connect(bp).connect(env).connect(output);
      noise.connect(hp);
      noise.start(time);
      noise.stop(time + 0.4);
    }

    function synthClapLoFi(time, state, output) {
      const slap = audioContext.createDelay(0.05);
      slap.delayTime.setValueAtTime(0.018, time);
      const feedback = audioContext.createGain();
      feedback.gain.value = 0.22;
      slap.connect(feedback).connect(slap);
      const slapGain = audioContext.createGain();
      slapGain.gain.setValueAtTime(0.2, time);
      slap.connect(slapGain).connect(output);

      const bursts = [0, 0.015, 0.03, 0.045];
      bursts.forEach((offset, index) => {
        const noise = audioContext.createBufferSource();
        noise.buffer = createNoiseBuffer();
        const filter = audioContext.createBiquadFilter();
        filter.type = "bandpass";
        filter.frequency.value = 1200 + index * 150;
        filter.Q.value = 0.7;
        const gain = audioContext.createGain();
        const level = 0.5 - index * 0.08;
        gain.gain.setValueAtTime(level, time + offset);
        gain.gain.exponentialRampToValueAtTime(0.001, time + offset + 0.2 + state.decay * 0.2);

        noise.connect(filter).connect(gain).connect(output);
        noise.connect(filter).connect(slap);
        noise.start(time + offset);
        noise.stop(time + offset + 0.4);
      });
    }

    function synthTomLoFi(time, state, output) {
      const osc = audioContext.createOscillator();
      const osc2 = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.type = "sine";
      osc2.type = "triangle";

      const base = midiToFreq(45 + state.pitch);
      osc.frequency.setValueAtTime(base, time);
      osc.frequency.exponentialRampToValueAtTime(base * 0.75, time + 0.12);
      osc2.frequency.setValueAtTime(base * 1.5, time);
      osc2.frequency.exponentialRampToValueAtTime(base * 1.15, time + 0.08);

      gain.gain.setValueAtTime(0.55, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.35 + state.decay * 0.45);

      const bodyFilter = audioContext.createBiquadFilter();
      bodyFilter.type = "lowpass";
      bodyFilter.frequency.value = 900;

      osc.connect(gain).connect(bodyFilter).connect(output);
      osc2.connect(gain);

      const click = audioContext.createBufferSource();
      click.buffer = createNoiseBuffer();
      const clickFilter = audioContext.createBiquadFilter();
      clickFilter.type = "highpass";
      clickFilter.frequency.value = 1800;
      const clickGain = audioContext.createGain();
      clickGain.gain.setValueAtTime(0.18, time);
      clickGain.gain.exponentialRampToValueAtTime(0.001, time + 0.06);
      click.connect(clickFilter).connect(clickGain).connect(output);

      osc.start(time);
      osc2.start(time);
      click.start(time);
      osc.stop(time + 0.9);
      osc2.stop(time + 0.9);
      click.stop(time + 0.1);
    }

    function synthPercLoFi(time, state, output) {
      const carrier = audioContext.createOscillator();
      const modOsc = audioContext.createOscillator();
      const modGain = audioContext.createGain();
      const gain = audioContext.createGain();

      const base = midiToFreq(60 + state.pitch);
      carrier.type = "sine";
      carrier.frequency.setValueAtTime(base, time);

      modOsc.type = "triangle";
      modOsc.frequency.setValueAtTime(base * 2.6, time);
      modGain.gain.setValueAtTime(140 + (state.lfo || 0) * 200, time);
      modOsc.connect(modGain).connect(carrier.frequency);

      const band = audioContext.createBiquadFilter();
      band.type = "bandpass";
      band.frequency.value = 1800;
      band.Q.value = 0.9;

      gain.gain.setValueAtTime(0.4, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.18 + state.decay * 0.2);

      carrier.connect(band).connect(gain).connect(output);

      carrier.start(time);
      modOsc.start(time);
      carrier.stop(time + 0.6);
      modOsc.stop(time + 0.6);
    }

    function synthRideLoFi(time, state, output) {
      const ratios = [1, 1.41, 1.72, 2.08, 2.5, 2.99];
      const base = 520 + randomInRange(-60, 60);
      const mix = audioContext.createGain();
      mix.gain.value = 0.5;

      ratios.forEach((ratio) => {
        const osc = audioContext.createOscillator();
        osc.type = "square";
        osc.frequency.setValueAtTime(base * ratio, time);
        osc.connect(mix);
        osc.start(time);
        osc.stop(time + 1.2);
      });

      const noise = audioContext.createBufferSource();
      noise.buffer = createNoiseBuffer();
      const hp = audioContext.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.value = 4200;
      const bp = audioContext.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.value = 6400;
      bp.Q.value = 0.6;

      const env = audioContext.createGain();
      env.gain.setValueAtTime(0.3, time);
      env.gain.exponentialRampToValueAtTime(0.001, time + 0.7 + state.decay * 0.6);

      mix.connect(hp).connect(bp).connect(env).connect(output);
      noise.connect(hp);
      noise.start(time);
      noise.stop(time + 1.3);
    }

    function synthFxLoFi(time, state, output) {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();
      filter.type = "bandpass";

      const startFreq = midiToFreq(38 + state.pitch);
      const endFreq = midiToFreq(26 + state.pitch);
      osc.type = "sawtooth";
      osc.frequency.setValueAtTime(startFreq, time);
      osc.frequency.exponentialRampToValueAtTime(endFreq, time + 0.6);

      filter.frequency.setValueAtTime(500, time);
      filter.frequency.exponentialRampToValueAtTime(4200, time + 0.4);
      filter.Q.value = 0.7;

      const wobble = createLfo((state.lfo || 0.2) * 0.8, time);
      wobble.connect(filter.frequency);

      gain.gain.setValueAtTime(0.5, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.8 + state.decay * 0.4);

      osc.connect(filter).connect(gain).connect(output);
      osc.start(time);
      osc.stop(time + 1.2);
    }

function synthDustLayer(time, output, gainAmount) {
      const noise = audioContext.createBufferSource();
      noise.buffer = createNoiseBuffer();
      const filter = audioContext.createBiquadFilter();
      filter.type = "lowpass";
      filter.frequency.value = 2200;
      const gain = audioContext.createGain();
      gain.gain.setValueAtTime(gainAmount, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
      noise.connect(filter).connect(gain).connect(output);
      noise.start(time);
      noise.stop(time + 0.3);
    }

    function getLockedValue(step, key, fallback) {
      return step.locks[key] !== null ? step.locks[key] : fallback;
    }

    function playSample(buffer, time, destination, pitch, slice, stretch, stepDuration) {
      if (stretch !== 1) {
        playGranular(buffer, time, destination, pitch, slice, stretch, stepDuration);
        return;
      }
      const source = audioContext.createBufferSource();
      source.buffer = buffer;
      const sagRate = centsToRate(-(2 + 8 * behavior.heat));
      source.playbackRate.value = Math.pow(2, pitch / 12) * sagRate;
      const sliceDur = buffer.duration / 16;
      const offset = clamp(slice, 0, 15) * sliceDur;
      source.connect(destination);
      source.start(time, offset, Math.min(sliceDur, stepDuration));
      source.stop(time + Math.min(sliceDur, stepDuration) + 0.05);
    }

    function playGranular(buffer, time, destination, pitch, slice, stretch, stepDuration) {
      const sliceDur = buffer.duration / 16;
      const sliceStart = clamp(slice, 0, 15) * sliceDur;
      const grainDur = Math.min(0.12, sliceDur * 0.8);
      const interval = grainDur * 0.5;
      const sagRate = centsToRate(-(2 + 8 * behavior.heat));
      const rate = Math.pow(2, pitch / 12) * sagRate;
      const grains = Math.max(3, Math.floor(stepDuration / interval));
      for (let i = 0; i < grains; i++) {
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.playbackRate.value = rate;
        const offset = sliceStart + (i * interval * rate) / stretch;
        source.connect(destination);
        source.start(time + i * interval, clamp(offset, 0, buffer.duration - grainDur), grainDur);
        source.stop(time + i * interval + grainDur + 0.02);
      }
    }

    function createTrackFxNodes(trackIndex) {
      const input = audioContext.createGain();
      const tensor = createTensorProcessor(trackIndex);
      const filter = audioContext.createBiquadFilter();
      filter.type = "lowpass";

      const distortion = audioContext.createWaveShaper();
      distortion.oversample = "2x";

      const crusher = createBitCrusher(0);
      const delay = audioContext.createDelay(1.0);
      const feedback = audioContext.createGain();
      delay.connect(feedback).connect(delay);

      const convolver = audioContext.createConvolver();
      convolver.buffer = reverbImpulse;

      const dry = audioContext.createGain();
      const wet = audioContext.createGain();

      const output = audioContext.createGain();
      input.connect(tensor);
      tensor.connect(dry);
      tensor.connect(filter).connect(distortion).connect(crusher).connect(delay).connect(convolver).connect(wet);
      dry.connect(output);
      wet.connect(output);

      return { input, output, tensor, filter, distortion, crusher, delay, feedback, convolver, dry, wet, trackIndex, lastCrushStep: -1, lastCrushNodeUpdateTime: 0 };
    }

    function updateTrackFx(chain, filterCutoff, resonance, state, fxMix, time) {
      const dryAppliesToTrack = dryModeEnabled && chain.trackIndex === selectedTrackIndex;
      const focused = dryAppliesToTrack ? fxFocusEffect : "all";
      const bypassAll = dryAppliesToTrack && focused === "none";
      const useDist = focused === "all" ? state.dist : (focused === "dist" ? state.dist : 0);
      const useCrush = focused === "all" ? state.crush : (focused === "crush" ? state.crush : 0);
      const useDelay = focused === "all" ? state.delay : (focused === "delay" ? state.delay : 0);
      const useReverb = focused === "all" ? state.reverb : (focused === "reverb" ? state.reverb : 0);
      const useFxMix = bypassAll ? 0 : (focused === "all" ? fxMix : 0.95);
      const cutoff = bypassAll ? 8000 : filterCutoff;
      const q = bypassAll ? 0.1 : clamp(resonance, 0.1, 12);

      chain.filter.frequency.setValueAtTime(cutoff, time);
      chain.filter.Q.value = q;
      chain.distortion.curve = createDistortionCurve(1 + useDist * 4);
      const crushStep = Math.round(clamp(useCrush, 0, 1) * 8);
      const canUpdateCrusher = (time - chain.lastCrushNodeUpdateTime) > 0.08;
      if (crushStep !== chain.lastCrushStep && canUpdateCrusher) {
        const crushAmount = crushStep / 8;
        try { chain.crusher.disconnect(); } catch (err) {}
        chain.crusher = createBitCrusher(crushAmount);
        try { chain.filter.disconnect(); } catch (err) {}
        chain.filter.connect(chain.distortion).connect(chain.crusher).connect(chain.delay);
        chain.lastCrushStep = crushStep;
        chain.lastCrushNodeUpdateTime = time;
      }
      chain.delay.delayTime.value = clamp(0.18 + useDelay * 0.25, 0.01, 0.6);
      chain.feedback.gain.value = clamp(0.2 + useDelay * 0.5, 0, 0.9);
      chain.convolver.buffer = reverbImpulse;
      chain.dry.gain.value = 1 - useFxMix;
      chain.wet.gain.value = useFxMix * (0.5 + useReverb * 0.5);
    }

    function createReverbImpulse(duration, decay) {
      const length = audioContext.sampleRate * duration;
      const impulse = audioContext.createBuffer(2, length, audioContext.sampleRate);
      for (let c = 0; c < 2; c++) {
        const channel = impulse.getChannelData(c);
        for (let i = 0; i < length; i++) {
          channel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
      }
      return impulse;
    }

    function createDistortionCurve(amount) {
      const curve = new Float32Array(256);
      for (let i = 0; i < 256; i++) {
        const x = (i / 255) * 2 - 1;
        curve[i] = Math.tanh(x * amount);
      }
      return curve;
    }

    function createBitCrusher(amount) {
      if (amount <= 0.06) {
        return audioContext.createGain();
      }
      const node = audioContext.createScriptProcessor(1024, 1, 1);
      const bits = Math.max(2, Math.floor(16 - amount * 12));
      const step = Math.pow(0.5, bits);
      node.onaudioprocess = (event) => {
        const input = event.inputBuffer.getChannelData(0);
        const output = event.outputBuffer.getChannelData(0);
        for (let i = 0; i < input.length; i++) {
          output[i] = Math.round(input[i] / step) * step;
        }
      };
      return node;
    }

    function createLfo(amount, time) {
      const lfo = audioContext.createOscillator();
      const gain = audioContext.createGain();
      lfo.type = "sine";
      lfo.frequency.setValueAtTime(2.1, time);
      gain.gain.setValueAtTime(amount * 0.3, time);
      lfo.connect(gain);
      lfo.start(time);
      lfo.stop(time + 0.6);
      return gain;
    }

    function createNoiseBuffer() {
      const bufferSize = audioContext.sampleRate * 0.4;
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      return buffer;
    }

    function createWaveshaper(amount) {
      const shaper = audioContext.createWaveShaper();
      shaper.curve = createSaturationCurve(amount);
      shaper.oversample = "2x";
      return shaper;
    }

    function createSaturationCurve(amount) {
      const curve = new Float32Array(256);
      for (let i = 0; i < 256; i++) {
        const x = (i / 255) * 2 - 1;
        curve[i] = Math.tanh(x * amount * 2);
      }
      return curve;
    }

    function midiToFreq(note) {
      return 440 * Math.pow(2, (note - 69) / 12);
    }

    function start() {
      initAudio();
      if (audioContext.state === "suspended") {
        audioContext.resume();
      }
      startEnergyMeter();
      isPlaying = true;
      currentStep = 0;
      nextNoteTime = audioContext.currentTime + 0.05;
      schedule();
      playButton.textContent = "Pause";
      playButton.classList.add("active");
    }

    function stop() {
      isPlaying = false;
      playButton.textContent = "Play";
      playButton.classList.remove("active");
      stopEnergyMeter();
      if (schedulerId) {
        cancelAnimationFrame(schedulerId);
      }
    }

    const playButton = document.getElementById("play");
    playButton.addEventListener("click", () => {
      if (!isPlaying) start();
      else stop();
    });

    document.getElementById("stop").addEventListener("click", () => {
      stop();
      currentStep = 0;
    });

    document.getElementById("clear").addEventListener("click", () => {
      resetSequence();
    });

    document.getElementById("reroll").addEventListener("click", () => {
      rollHumanizeForAllSteps();
    });

    document.getElementById("resampleMaster").addEventListener("click", () => {
      resampleMaster();
    });

    document.getElementById("sketchA").addEventListener("click", () => sketchPocket());
    document.getElementById("sketchB").addEventListener("click", () => sketchLurch());
    document.getElementById("sketchC").addEventListener("click", () => sketchShuffle());
    document.getElementById("sketchHouse").addEventListener("click", () => sketchHouse());
    document.getElementById("sketchTechno").addEventListener("click", () => sketchTechno());
    document.getElementById("sketchHipHop").addEventListener("click", () => sketchHipHop());
    if (sketchSurprise) sketchSurprise.addEventListener("click", () => surpriseSketch());

    document.querySelectorAll("[data-lock-track]").forEach((input) => {
      const pill = input.closest(".lock-pill");
      if (pill) pill.classList.toggle("locked", input.checked);
      input.addEventListener("change", (event) => {
        const idx = Number(event.target.dataset.lockTrack);
        if (event.target.checked) sketchLocks.add(idx);
        else sketchLocks.delete(idx);
        const lockPill = event.target.closest(".lock-pill");
        if (lockPill) lockPill.classList.toggle("locked", event.target.checked);
      });
    });

    recordButton.addEventListener("click", () => {
      if (!isRecording) startRecording();
      else stopRecording();
    });
    exportWavButton.addEventListener("click", () => {
      if (isRecording) stopRecording();
      exportWav();
    });

    tempo.addEventListener("input", () => {
      tempoValue.textContent = tempo.value;
      tempoNumber.value = tempo.value;
    });

    tempoNumber.addEventListener("input", () => {
      const value = clamp(Number(tempoNumber.value), 88, 140);
      tempo.value = value;
      tempoValue.textContent = value;
    });

    swing.addEventListener("input", () => {
      swingValue.textContent = swing.value;
    });

    tape.addEventListener("input", () => {
      tapeValue.textContent = tape.value;
      if (masterSaturation) updateTape();
    });

    layer.addEventListener("input", () => {
      layerValue.textContent = layer.value;
    });

    groovePreset.addEventListener("change", () => {
      applyHumanizePreset(groovePreset.value);
    });

    looseness.addEventListener("input", () => {
      humanize.looseness = Number(looseness.value);
      loosenessValue.textContent = looseness.value;
    });

    velVar.addEventListener("input", () => {
      humanize.velocityVar = Number(velVar.value) / 100;
      velVarValue.textContent = `${velVar.value}%`;
    });

    swingVar.addEventListener("input", () => {
      humanize.swingVar = Number(swingVar.value);
      swingVarValue.textContent = swingVar.value;
    });

    pulse.addEventListener("input", () => {
      humanize.pulseDrift = Number(pulse.value);
      pulseValue.textContent = Number(pulse.value).toFixed(1);
    });

    detune.addEventListener("input", () => {
      humanize.detune = Number(detune.value);
      detuneValue.textContent = Number(detune.value).toFixed(1);
    });

    mod.addEventListener("input", () => {
      humanize.mod = Number(mod.value) / 100;
      modValue.textContent = `${mod.value}%`;
    });

    if (chaos) {
      chaos.addEventListener("input", () => {
        if (chaosValue) chaosValue.textContent = chaos.value;
      });
    }
    if (pressure) {
      pressure.addEventListener("input", () => {
        pressureAmount = Number(pressure.value) / 100;
        behavior.pressure = pressureAmount;
        if (pressureValue) pressureValue.textContent = Math.round(pressureAmount * 100);
      });
    }
    if (headroomMode) {
      headroomMode.addEventListener("change", () => {
        headroomModeValue = headroomMode.value;
      });
    }
    if (headroomAmount) {
      headroomAmount.addEventListener("input", () => {
        headroomAmountValueNum = Number(headroomAmount.value) / 100;
        if (headroomAmountValue) headroomAmountValue.textContent = `${Math.round(headroomAmountValueNum * 100)}%`;
      });
    }
    if (velocityCrushMode) {
      velocityCrushMode.addEventListener("change", () => {
        velocityCrushModeValue = velocityCrushMode.value;
      });
    }
    if (evolutionAmountSlider) {
      evolutionAmountSlider.addEventListener("input", () => {
        evolutionAmount = Number(evolutionAmountSlider.value) / 100;
        if (evolutionAmountValue) evolutionAmountValue.textContent = `${Math.round(evolutionAmount * 100)}%`;
      });
    }

    function updateFxFocusInfo() {
      if (!fxFocusInfo) return;
      if (!dryModeEnabled) {
        fxFocusInfo.textContent = "Dry mode off";
        return;
      }
      const trackName = tracks[selectedTrackIndex] ? tracks[selectedTrackIndex].name : `T${selectedTrackIndex + 1}`;
      fxFocusInfo.textContent = fxFocusEffect === "none"
        ? `Bypassed FX on ${trackName}`
        : `Auditioning ${fxFocusEffect.toUpperCase()} on ${trackName}`;
    }

    function updateStressVisual() {
      const stressVisual = clamp01(behavior.stress * 0.7 + behavior.heat * 0.3);
      if (stressFill) stressFill.style.height = `${Math.round(stressVisual * 100)}%`;
      if (stressText) stressText.textContent = `${Math.round(stressVisual * 100)}%`;
      if (densityReactInfo) densityReactInfo.textContent = `Density React ${Math.round(densityReactAmount * 100)}%`;
      if (sagInfo) sagInfo.textContent = `Sag ${Math.round(behavior.sagCents)}c`;
    }
    if (dryMode) {
      dryMode.addEventListener("change", () => {
        dryModeEnabled = dryMode.checked;
        updateFxFocusInfo();
        if (masterSaturation) updateTape();
      });
    }
    if (fxFocus) {
      fxFocus.addEventListener("change", () => {
        fxFocusEffect = fxFocus.value;
        updateFxFocusInfo();
      });
    }

    function syncTensorStateFromUI() {
      if (tensorEnable) tensorState.enabled = tensorEnable.checked;
      if (tensorBlend) tensorState.blend = clamp(Number(tensorBlend.value) / 100, 0, 1);
      if (tensorSpeed) tensorState.speed = clamp(Number(tensorSpeed.value) / 100, -2, 2);
      if (tensorPitch) tensorState.pitchSemitones = clamp(Number(tensorPitch.value), -12, 12);
      if (tensorStretch) tensorState.stretch = clamp(Number(tensorStretch.value) / 100, 0.5, 2);
      if (tensorStopTime) tensorState.stopTimeMs = clamp(Number(tensorStopTime.value), 50, 2000);
      if (tensorReverseMode) tensorState.reverseMode = tensorReverseMode.value;
      if (tensorFreeze) tensorState.freeze = tensorFreeze.checked;
      if (tensorLoopLength) tensorState.loopMs = clamp(Number(tensorLoopLength.value), 250, 9400);
      if (tensorRandomAmount) tensorState.randomAmount = clamp(Number(tensorRandomAmount.value) / 100, 0, 1);
      if (tensorRandomTrigger) tensorState.randomTrigger = clamp(Number(tensorRandomTrigger.value) / 100, 0, 1);
      if (tensorSmooth) tensorState.smooth = clamp(Number(tensorSmooth.value) / 100, 0, 1);
      updateTensorStatus();
    }

    function syncTensorValueLabels() {
      if (tensorBlendValue && tensorBlend) tensorBlendValue.textContent = `${tensorBlend.value}%`;
      if (tensorSpeedValue && tensorSpeed) tensorSpeedValue.textContent = `${tensorSpeed.value}%`;
      if (tensorPitchValue && tensorPitch) tensorPitchValue.textContent = `${tensorPitch.value} st`;
      if (tensorStretchValue && tensorStretch) tensorStretchValue.textContent = `${tensorStretch.value}%`;
      if (tensorStopValue && tensorStopTime) tensorStopValue.textContent = `${tensorStopTime.value} ms`;
      if (tensorLoopValue && tensorLoopLength) tensorLoopValue.textContent = `${tensorLoopLength.value} ms`;
      if (tensorRandomValue && tensorRandomAmount) tensorRandomValue.textContent = `${tensorRandomAmount.value}%`;
      if (tensorTriggerValue && tensorRandomTrigger) tensorTriggerValue.textContent = `${tensorRandomTrigger.value}%`;
      if (tensorSmoothValue && tensorSmooth) tensorSmoothValue.textContent = `${tensorSmooth.value}%`;
    }

    if (tensorEnable) tensorEnable.addEventListener("change", syncTensorStateFromUI);
    if (tensorBlend) tensorBlend.addEventListener("input", () => { syncTensorValueLabels(); syncTensorStateFromUI(); });
    if (tensorSpeed) tensorSpeed.addEventListener("input", () => { syncTensorValueLabels(); syncTensorStateFromUI(); });
    if (tensorPitch) tensorPitch.addEventListener("input", () => { syncTensorValueLabels(); syncTensorStateFromUI(); });
    if (tensorStretch) tensorStretch.addEventListener("input", () => { syncTensorValueLabels(); syncTensorStateFromUI(); });
    if (tensorStopTime) tensorStopTime.addEventListener("input", () => { syncTensorValueLabels(); syncTensorStateFromUI(); });
    if (tensorReverseMode) tensorReverseMode.addEventListener("change", syncTensorStateFromUI);
    if (tensorFreeze) tensorFreeze.addEventListener("change", syncTensorStateFromUI);
    if (tensorLoopLength) tensorLoopLength.addEventListener("input", () => { syncTensorValueLabels(); syncTensorStateFromUI(); });
    if (tensorRandomAmount) tensorRandomAmount.addEventListener("input", () => { syncTensorValueLabels(); syncTensorStateFromUI(); });
    if (tensorRandomTrigger) tensorRandomTrigger.addEventListener("input", () => { syncTensorValueLabels(); syncTensorStateFromUI(); });
    if (tensorSmooth) tensorSmooth.addEventListener("input", () => { syncTensorValueLabels(); syncTensorStateFromUI(); });

    if (tensorReverseHold) {
      const holdStart = () => {
        tensorState.reverseHeld = true;
        if (tensorReverseMode && tensorReverseMode.value !== "momentary") tensorReverseMode.value = "momentary";
        syncTensorStateFromUI();
      };
      const holdEnd = () => {
        tensorState.reverseHeld = false;
        syncTensorStateFromUI();
      };
      tensorReverseHold.addEventListener("pointerdown", holdStart);
      tensorReverseHold.addEventListener("pointerup", holdEnd);
      tensorReverseHold.addEventListener("pointerleave", holdEnd);
      tensorReverseHold.addEventListener("pointercancel", holdEnd);
    }
    if (tensorReverseLatch) {
      tensorReverseLatch.addEventListener("click", () => {
        tensorState.reverseLatched = !tensorState.reverseLatched;
        tensorReverseLatch.classList.toggle("active", tensorState.reverseLatched);
        if (tensorReverseMode && tensorReverseMode.value !== "latch") tensorReverseMode.value = "latch";
        syncTensorStateFromUI();
      });
    }

    function setXYFromValues() {
      const x = mapRange(Number(swing.value), 0, 70, 0, 100);
      const y = mapRange(humanize.looseness, 0, 40, 0, 100);
      xyCrosshair.style.setProperty("--x", `${x}%`);
      xyCrosshair.style.setProperty("--y", `${100 - y}%`);
      xyHandle.style.setProperty("--x", `${x}%`);
      xyHandle.style.setProperty("--y", `${100 - y}%`);
    }

    function updateFromXY(clientX, clientY) {
      const rect = xyPad.getBoundingClientRect();
      const x = clamp((clientX - rect.left) / rect.width, 0, 1);
      const y = clamp((clientY - rect.top) / rect.height, 0, 1);
      const swingValueRaw = Math.round(mapRange(x, 0, 1, 0, 70));
      const loosenessRaw = Math.round(mapRange(1 - y, 0, 1, 0, 40));
      swing.value = swingValueRaw;
      swingValue.textContent = swingValueRaw;
      humanize.looseness = loosenessRaw;
      looseness.value = loosenessRaw;
      loosenessValue.textContent = loosenessRaw;
      setXYFromValues();
    }

    xyPad.addEventListener("pointerdown", (event) => {
      xyPad.setPointerCapture(event.pointerId);
      updateFromXY(event.clientX, event.clientY);
    });
    xyPad.addEventListener("pointermove", (event) => {
      if (event.buttons) updateFromXY(event.clientX, event.clientY);
    });

    stepChance.addEventListener("input", () => {
      if (!selectedStep) return;
      const step = sequence[selectedStep.trackIndex][selectedStep.stepIndex];
      step.cond.chance = Number(stepChance.value);
      chanceValue.textContent = `${stepChance.value}%`;
    });

    stepEvery.addEventListener("input", () => {
      if (!selectedStep) return;
      const step = sequence[selectedStep.trackIndex][selectedStep.stepIndex];
      step.cond.every = Number(stepEvery.value);
      everyValue.textContent = stepEvery.value;
    });

    lockPitch.addEventListener("input", () => {
      lockPitchValue.textContent = lockPitch.value;
      updateSelectedStepLock("pitch", Number(lockPitch.value), lockPitchEnable.checked);
    });
    lockPitchEnable.addEventListener("change", () => {
      updateSelectedStepLock("pitch", Number(lockPitch.value), lockPitchEnable.checked);
    });

    lockReverse.addEventListener("change", () => {
      if (!selectedStep) return;
      updateSelectedStepLock("reverse", lockReverse.checked, true);
      lockReverseValue.textContent = lockReverse.checked ? "On" : "Off";
    });

    lockSlice.addEventListener("input", () => {
      lockSliceValue.textContent = lockSlice.value;
      updateSelectedStepLock("slice", Number(lockSlice.value), lockSliceEnable.checked);
    });
    lockSliceEnable.addEventListener("change", () => {
      updateSelectedStepLock("slice", Number(lockSlice.value), lockSliceEnable.checked);
    });

    lockStretch.addEventListener("input", () => {
      lockStretchValue.textContent = Number(lockStretch.value).toFixed(1);
      updateSelectedStepLock("stretch", Number(lockStretch.value), lockStretchEnable.checked);
    });
    lockStretchEnable.addEventListener("change", () => {
      updateSelectedStepLock("stretch", Number(lockStretch.value), lockStretchEnable.checked);
    });

    lockFilter.addEventListener("input", () => {
      lockFilterValue.textContent = lockFilter.value;
      updateSelectedStepLock("filter", Number(lockFilter.value), lockFilterEnable.checked);
    });
    lockFilterEnable.addEventListener("change", () => {
      updateSelectedStepLock("filter", Number(lockFilter.value), lockFilterEnable.checked);
    });

    lockRes.addEventListener("input", () => {
      lockResValue.textContent = Number(lockRes.value).toFixed(1);
      updateSelectedStepLock("resonance", Number(lockRes.value), lockResEnable.checked);
    });
    lockResEnable.addEventListener("change", () => {
      updateSelectedStepLock("resonance", Number(lockRes.value), lockResEnable.checked);
    });

    lockDecay.addEventListener("input", () => {
      lockDecayValue.textContent = Number(lockDecay.value).toFixed(2);
      updateSelectedStepLock("decay", Number(lockDecay.value), lockDecayEnable.checked);
    });
    lockDecayEnable.addEventListener("change", () => {
      updateSelectedStepLock("decay", Number(lockDecay.value), lockDecayEnable.checked);
    });

    lockFx.addEventListener("input", () => {
      lockFxValue.textContent = `${lockFx.value}%`;
      updateSelectedStepLock("fx", Number(lockFx.value) / 100, lockFxEnable.checked);
    });
    lockFxEnable.addEventListener("change", () => {
      updateSelectedStepLock("fx", Number(lockFx.value) / 100, lockFxEnable.checked);
    });

    clearLocks.addEventListener("click", () => {
      if (!selectedStep) return;
      const step = sequence[selectedStep.trackIndex][selectedStep.stepIndex];
      step.locks = { pitch: null, reverse: null, stretch: null, slice: null, filter: null, resonance: null, decay: null, fx: null };
      selectStep(selectedStep.trackIndex, selectedStep.stepIndex);
    });

    document.addEventListener("click", (event) => {
      const tabBtn = event.target.closest(".tab-btn");
      if (tabBtn) setTab(tabBtn.dataset.tab);
      const modeBtn = event.target.closest("[data-mode]");
      if (modeBtn) setMode(modeBtn.dataset.mode);
    });

    window.addEventListener("resize", lockSequencerRowHeights);

    document.addEventListener("keydown", (event) => {
      if (event.key === "Shift") {
        document.body.classList.add("show-velocity");
      }
      if (event.code === "Space") {
        event.preventDefault();
        if (!isPlaying) start();
        else stop();
      }
      if (event.key === "r" || event.key === "R") {
        rollHumanizeForAllSteps();
      }
      if (event.key === "1") sketchPocket();
      if (event.key === "2") sketchLurch();
      if (event.key === "3") sketchShuffle();
      if (event.key === "4") sketchHouse();
      if (event.key === "5") sketchTechno();
      if (event.key === "6") sketchHipHop();
    });
    document.addEventListener("keyup", (event) => {
      if (event.key === "Shift") {
        document.body.classList.remove("show-velocity");
      }
    });
    window.addEventListener("blur", () => {
      document.body.classList.remove("show-velocity");
    });

    // Initialize humanize UI with default preset.
    applyHumanizePreset("loose");
    setXYFromValues();
    if (chaos && chaosValue) chaosValue.textContent = chaos.value;
    if (pressure) {
      pressureAmount = Number(pressure.value) / 100;
      behavior.pressure = pressureAmount;
      if (pressureValue) pressureValue.textContent = pressure.value;
    }
    if (headroomMode) headroomModeValue = headroomMode.value;
    if (headroomAmount && headroomAmountValue) {
      headroomAmountValueNum = Number(headroomAmount.value) / 100;
      headroomAmountValue.textContent = `${Math.round(headroomAmountValueNum * 100)}%`;
    }
    if (velocityCrushMode) velocityCrushModeValue = velocityCrushMode.value;
    if (evolutionAmountSlider && evolutionAmountValue) {
      evolutionAmount = Number(evolutionAmountSlider.value) / 100;
      evolutionAmountValue.textContent = `${Math.round(evolutionAmount * 100)}%`;
    }
    syncTensorValueLabels();
    syncTensorStateFromUI();
    if (dryMode) dryModeEnabled = dryMode.checked;
    if (fxFocus) fxFocusEffect = fxFocus.value;
    updateFxFocusInfo();
    updateStressVisual();
    if (evolutionMemoryInfo) evolutionMemoryInfo.textContent = `Memory ${evolutionMemory.length}/${evolutionMemoryLimit}`;
    setMode("edit");
    setSelectedTrack(0);
    setVariationIndicator(quickVariation, quickVariationValue, 0);
    setVariationIndicator(genreVariation, genreVariationValue, 0);
    renderPalettePanel();
    tracks.forEach((_, i) => updateKnobVisual(i));
  </script>
</body>
</html>


